{"meta":{"title":"Alex Technical Art","subtitle":"","description":"","author":"Alex Tsui","url":"https://cuihongzhi1991.github.io","root":"/blog/"},"pages":[{"title":"Real-Time Rendering 4th 笔记——第一章","date":"2020-04-11T12:33:36.000Z","updated":"2020-04-16T14:36:49.284Z","comments":true,"path":"DOING/RTR4Ch01.html","permalink":"https://cuihongzhi1991.github.io/DOING/RTR4Ch01.html","excerpt":"《Real-Time Rendering 4th》出版于2018年，是实时渲染圣经的第四版。此版涵盖的内容延续以往的结构，知识点到为止，展开的并不多。所以根据书中的索引可以对某一方面进行深度学习和研究。","text":"《Real-Time Rendering 4th》出版于2018年，是实时渲染圣经的第四版。此版涵盖的内容延续以往的结构，知识点到为止，展开的并不多。所以根据书中的索引可以对某一方面进行深度学习和研究。 引言实时渲染是计算机图形学交互性最强的领域。操作者做出操作或交互后可以立即得到反馈效果呈现在画面上，并根据产生的图像结果持续交互。这样一个操作与渲染的循环须有足够的计算速度才可以避免观察者看到多张不连贯的图像。图像显示速率以帧数/秒(FPS)或者赫兹(Hz)度量。每秒1帧几乎没有交互性；每秒6帧才有点交互性；游戏的目标是30、60、72或更高的FPS，例如游戏在VR头显设备运行时通常需要90FPS来最小化延迟避免产生眩晕感。实时渲染比交互性更重要，实时渲染一般指创造三维图像。交互性和三维空间关系是实时渲染的充分条件。后来，三维图形的加速硬件（显卡）也成为了实时渲染的第三个元素。不仅是电脑，平板和手机现在也内置了图形处理器。本书会着重提供可以加速和提升画面质量的方法，并且会描述加速算法和图形API的特性及限制。本书不会对每个话题深入讨论，而是展现其核心概念和专业术语，对最鲁棒和最实际的算法进行解释，并给出更多的拓展学习资料。 内容概括 第二章——图形渲染管线将场景的数据化抽象描述转换成我们可以看到的实际画面的步骤就是实时渲染的核心。 第三章——图形处理单元现代GPU使用固定方法与可编程单元的组合来实现渲染管线的各个步骤。 第四章——变换变换是修改物体位置、朝向、比例和形状的基本工具，也是修改相机位置和FOV的基本工具。 第五章——基础着色从讨论材质和灯光的含义开始，并实现写实或风格化的材质效果。另外还会介绍一些效果相关的话题，比如通过反走样、半透和伽马矫正得到质量更佳的图像。 第六章——纹理快速读取和在表面上显示图像的能力是实时渲染的强力工具之一。这个过程被称为纹理映射，有着很广泛的应用方法。 第七章——阴影给场景添加阴影既可以提升真实感也便于理解空间关系。本章会快速展示一下常用的计算阴影的算法。 第八章——光和色彩在呈现基于物理的渲染之前，需要理解如何量化光和色彩。在物理渲染过程结束后，需要转换结果为数值来展示效果，包括屏幕和观察环境的多种属性。 第九章——基于物理的着色本章会透彻讲解对基于物理的着色。会介绍背后的物理现象、各种渲染材质的数学模型、混合材质和反走样的过滤方法。 第十章——局部照明探索更精准的光照算法。当光源具有特殊形状时是如何计算表面的着色。 第十一章——全局照明模拟灯光和场景多次交互的算法大大增加图像的真实性。会讨论直接和间接光遮蔽以及渲染漫反射和镜面反射表面的全局光照的方法，还有一些可信的统一实现方式。 第十二章——图像效果图形硬件擅长快速处理图像。会先介绍图像过滤和重映射技术，然后讨论几个流行的后期处理效果，如：镜头炫光、运动模糊和景深。 第十三章——物体的其他描述形式三角形不总是描述物体最快和最真实的方式。还有一些基于图像、点云、体素和其他采样集合的方式都有各自的优点。 第十四章——体积和半透渲染重现体积感材质的理论和实践，他们是如何与光照进行交互的。从宏观的大范围氛围效果到微观如发丝的光照散射都有模拟。 第十五章——非真实感渲染让场景看起来真实只是渲染的方法之一。还可以探讨其他类型，如卡通着色、水彩风格等，线条和文本的生成技术也会在此讨论。 第十六章——多边形技术几何数据来源广泛，有时为了快速渲染和提高渲染质量会修改数据。本章会介绍描述和压缩多边形数据技术的多个方面。 第十七章——曲线和曲面更复杂的表面描述方式提供了其他的优点，比如可以在质量和渲染速度上做取舍、更加细致的描述以及生成平滑的表面。 第十八章——管线优化当应用程序使用高效的算法运行时，可以使用各种优化技术更快的运行。找到瓶颈并且决定如何解决瓶颈是本章的主题。多重处理也会在此讨论。 第十九章——加速算法不仅能运行，还要更快速。本章涵盖了各种剔除和LOD渲染方法。 第二十章——高效的着色方式在场景中，大量的光源会导致性能的下降。在片段可见性未知的情况下对其完整的渲染是浪费的。此处会探索一些可以解决这种低效着色的办法。 第二十一章——虚拟现实和增强现实该领域有其特殊的挑战和技术来实现真实、快速并且稳定的图像。 第二十二章——相交测试方法相交测试对渲染、玩家交互和碰撞检测都十分重要。本章会介绍很多几何体相交测试的高效算法。 第二十三章——图形硬件本章会介绍颜色深度、帧缓冲和基础的架构类型。给出了一个典型的GPU实例分析。 第二十四章——未来让我们猜猜看。 符号和定义TO DO 数学符号TO DO 几何定义TO DO 着色TO DO 其他学习资源Real-Time Rendering官网"},{"title":"UE4制作《地平线》体积云","date":"2020-04-17T15:30:14.000Z","updated":"2020-04-19T14:29:10.940Z","comments":true,"path":"DOING/VC-HZD2016.html","permalink":"https://cuihongzhi1991.github.io/DOING/VC-HZD2016.html","excerpt":"","text":"概览游戏中的实时体积云往往为了降低性能而降低质量。最成功的实现仅限于低空的蓬松半透的层状云。开发者提出一种有体积感的解决方案，可以用各种类型的云填满整个天空，十分真实。不仅描绘了高空的卷云，还有所有低云族的主要类型，包括厚的卷积云。另外，开发者的几中体积光效果的模拟方法还没有在这个体积云方案中呈现。最后，这个解决方案在内存和GPU开销方面表现得足够好，可以在3A的主机游戏中使用。 简介3A主机游戏云渲染的标准方案包括某些素材，比如2D公告板、带穹顶图的天空球或者体积素材库在渲染时进行实例化。像开放世界这样天空需要不断变化并且玩家视距非常远的游戏中，数据储存、多个相机角度、TOD和不同光照条件下的数据读取使得高细节资源的优势黯然失色。另外，云系统演化过程的模拟仅限于作假的方式，比如旋转天空球或者用2D噪波扭曲云的贴图。有许多不依赖资产的程序化云系统的技术。ShaderToy.com上有几个很好的免费案例，比如Quilez的“Clouds”。索尼的Evolution Studios在游戏《驾驶俱乐部》中使用TrueSky的插件呈现氛围感很强的天气效果。然而这种方式也有几个限制： 它们只描述了低高度的层云，不是蓬松汹涌的层积云或积云。 现有的方法没有针对特定的云实现真实的光照效果。 正常情况下，实时体积云性能开销很高，内存占用多，不值得为了质量好而牺牲这么多。对于游戏《地平线：黎明时分》，开发者研发了新的解决方案来解决上述的问题。他们为体积云的建模、光照和渲染提出了新的算法，在内存预算20MB和实时性能2ms的情况下实现真实和逐步演变的效果。 云的建模。。。。。。。。。。。。。。。。"},{"title":"categories","date":"2020-04-11T09:45:58.000Z","updated":"2020-04-11T09:54:15.732Z","comments":false,"path":"categories/index.html","permalink":"https://cuihongzhi1991.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-04-11T09:44:03.000Z","updated":"2020-04-11T09:54:17.823Z","comments":false,"path":"tags/index.html","permalink":"https://cuihongzhi1991.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"球面高斯函数01——光照贴图简史","slug":"sg01","date":"2020-05-01T06:14:25.000Z","updated":"2020-05-01T16:47:56.413Z","comments":true,"path":"2020/05/01/sg01/","link":"","permalink":"https://cuihongzhi1991.github.io/2020/05/01/sg01/","excerpt":"球面高斯函数(Spherical Gaussian, SG)是比较冷门的话题，但Ready At Dawn工作室却对其情有独钟，并使用在自家的游戏引擎中。其效果也经《教团：1886》得到验证。本系列是由Ready At Dawn工作室的首席图形和引擎工程师Matt Pettineo编写在自己的博客。我将该系列的学习笔记记录于此，与大家分享。","text":"球面高斯函数(Spherical Gaussian, SG)是比较冷门的话题，但Ready At Dawn工作室却对其情有独钟，并使用在自家的游戏引擎中。其效果也经《教团：1886》得到验证。本系列是由Ready At Dawn工作室的首席图形和引擎工程师Matt Pettineo编写在自己的博客。我将该系列的学习笔记记录于此，与大家分享。 原作者把球面高斯函数及其应用分为6篇介绍： Part1-光照贴图简史Part2-球面高斯函数101Part3-从SG光源重建漫反射光照Part4-从SG光源重建镜面反射光照Part5-用SG函数近似辐射率和辐射度Part6-Baking Lab的使用 最后一部分是他制作的开源的光照贴图烘焙Demo的使用方法，暂且不纳入笔记范围。笔记将记录前五篇的主要内容。作为该系列的第一篇，会简单介绍一下研究球面高斯函数(Spherical Gaussians, SG)时需要的背景资料。重点讨论预烘焙的光照贴图或探针存储了什么信息，以及如何使用信息来计算漫反射或高光。 开始前，可以看一下下文用到的术语符号： $L_o$ -指向观察方向的出射光辐射率(radiance)$L_i$ -表面入射点的入射光辐射率o -观察方向(着色器光照计算中一般用V表示)i -光线入射方向(着色器光照计算中一般用L表示)n -表面法向量x -表面上某点的3D坐标$\\int_{\\Omega}$ -半球积分$\\theta_i$ - 表面法线与入射光的夹角角度$\\theta_o$ - 表面法线与出射光的夹角角度$f\\left(\\right)$ -BRDF 早期方式——存储辐射度(irradiance)自从有了带颜色的3D游戏开始就有了预先计算光照贴图的方法，一直延续到现在(2020年)。原理比较简单：为每个纹素预先计算光照数值，然后在游戏运行时对光照数值进行采样来计算表面的最终效果。虽然原理简单，但细节就比较讲究了。比如将“光照”存储在纹理中到底意味着什么？或者计算的到底是什么值？在最早期，从光照贴图中获取的数值只是简单的与材质的漫反射颜色相乘，然后直接输出颜色到屏幕上。暂且不考虑伽马矫正和sRGB转换等等。根据上面简单的描述，可以使用渲染公式来描述这种古老的方法。 因为光照贴图每个纹素存储的都是单一的固定颜色值，所以可以不用考虑观察方向。仅使用简单的兰伯特漫反射BRDF即可。一般我们用以下的公式计算从一个入射点计算出射辐射率： \\begin{align} L_o(o,x) = \\int_{\\Omega}{}f(i,o,x)\\cdot L_i(i,x)\\cdot\\cos(\\theta_i)\\cdot{d}\\Omega \\nonumber \\end{align}如果用普通的漫反射BRDF(即$\\frac{C_{diffuse}}{\\pi}$)代替BRDF，那么就会变成： \\begin{align} L_o(o,x) = \\int_{\\Omega}{} \\frac{C_{diffuse}}{\\pi}\\cdot L_i(i,x)\\cdot\\cos(\\theta_i)\\cdot{d}\\Omega \\nonumber \\\\ = \\frac{C_{diffuse}}{\\pi}\\int_{\\Omega}{}L_i(i,x)\\cdot\\cos(\\theta_i)\\cdot{d}\\Omega \\nonumber \\end{align}可以看到将右侧的常量项$\\frac{C_{diffuse}}{\\pi}$提到积分外，这样右侧复杂的积分运算就是预计算(pre-computed)的纹素了，然后在运行时用常量项与每个纹素值相乘就是最终的颜色了。右侧的积分计算的是入射光辐射度，因此光照贴图中存储的就是辐射度值。实际上大多数的游戏并没有在运行时应用$\\frac{1}{\\pi}$,因为这是个常数项，为了降低开销可以也将这个常数项预计算在光照贴图中，这样只剩$C_{diffuse}$是在运行时参与计算的。这种情形下，实际存储的就是反射率。换言之，可以认为存储的值是当$C_{diffuse}=1.0$时漫反射的反射率，即具有漫反射BRDF的表面最大出射光辐射率。 法线贴图光照贴图的核心概念之一就是利用空间域中以不同速率存储的数据来重建表面的最终效果。简言之，使用一个纹素密度存储光照贴图，并与不同密度(一般更高)的反射率贴图(albedo map)结合。这样无需计算每个纹素的辐射度积分就可以保留高频细节。但如何让辐射度根据其他纹理贴图(不仅仅是反射率贴图)变化呢？为了满足这种需求，在2000年初法线贴图开始被广泛使用，但仅限于与精确光源(punctual light source)计算时使用。并且法线贴图对光照贴图不起作用，因为光照贴图只存储了单个辐射度的比例值，那么相比于直接光照区域，仅有环境光照(ambient lighting)的区域就非常的平整。如下图： 为了让光照贴图与法线贴图正确计算，光照贴图每个纹素不再存储单个标量值，而是辐射度的分布信息。法线贴图包含一定范围的方向分布信息，这些方向一般限制在表面上一个点的法线周围半球内。所以光照贴图存储的辐射度分布信息是定义在同一个半球内的。V社(Valve)使用自研的Source引擎在《半条命2》中最早使用了这种分布，被称为“辐射度法线贴图”。 V社修改了光照贴图烘焙器计算三个值而不是一个值，每个值都是通过投影辐射度到上图中某一个基向量(basis vector)上。游戏运行时，会基于法线贴图中的方向与三个基向量的夹角余弦值来混合三个光照贴图值从而得到辐射度值(通过开销很低的点积(dot product)就可以计算)。这样就可以根据法线贴图中的方向有效德改变辐射度，进而避免了仅有环境光的区域过于平整的问题。 这个方式解决了静态物体的问题，对动态的物体和角色应用预计算的光照依然有问题。一些早期游戏(如《Quake》)用了一些技巧,例如在角色脚部位置采样光照贴图的数值，并使用该数值计算出环境光数值应用到整个模型上。而有些游戏的处理方式更粗糙，只把动态灯光和一个全局的环境光项结合使用。V社使用了更复杂的方法，将半球光照贴图基础扩展成由6个正交基向量形成的球面基础。 基向量与一个单位立方体的六个面朝向重合，V社称之为“环境立方体”。使用他们的基函数(basis functions)将辐射度投影到空间中一点周围的所有方向上(而不是面法线周围的半球上)，动态的模型可以对任意法线方向采样辐射度来计算漫反射光照。这种形式被称为“光照探针”(lighting probe)或简称“探针”(probe)。 镜面反射通过V社提出的方法，可以使用高频的法线贴图与光照贴图进行计算得到漫反射光照。为了让画面更真实，还需要支持更加复杂的BRDF，包括受观察方向影响的镜面反射BRDF。《半条命2》通过预生成(pre-generating)的立方体贴图和手动摆放的探针来处理环境的镜面反射。这在现代游戏中也是十分常见的做法(额外添加了预过滤(pre-filtering)来近似微平面BRDF)。但立方体贴图会占用大量的内存空间，因此限制了镜面反射探针(specular probe)的密度，错误的视差(parallax)或遮挡自然会产生一些问题。下图中，由于错误的视差和遮挡，当使用预过滤的环境贴图计算环境镜面反射(environment specular)时，球的边缘反射了自己导致非常亮！ 因此需要让光照贴图对镜面反射同样有影响。如果模仿漫反射BRDF，将镜面反射BRDF从积分中提出来，BRDF Integrate(Lighting cos(theta))，而不是原本的Integrate(BRDF Lighting cos(theta))，那么仅仅在观察方向与光照贴图基向量方向接近的时候才能看到些许镜面反射效果。下方示意图展示了改变公式后的效果。 很明显这是错误的，因为兰伯特漫反射BRDF是常量项，可以从积分中提出来，但镜面反射BRDF是与入射光方向和视线方向有关的，不能从积分中提出来。 球谐函数球谐函数(Spherical Harmonics, SH)是实时图形一种流行的工具，通常作为在离散的探针位置存储间接光照近似值的方式。核心就是在球面上用一系列系数(1个、4个、9个、16个、n*n个)近似出一个关于方向(方向定义在球面上)的分布函数。就像使用一个方向向量从一张立方体贴图上获取特定的值。使用低阶的球谐函数只能表示非常低频的信号，下图使用27个系数(RGB每通道9个系数)将HDR图投影到L2球谐函数上。 对于辐射度来讲，低频的球谐函数非常适合。相对于余弦项的入射辐射率积分有效地充当了低通滤波器，非常适合用来与球谐函数去逼近辐射度。如果将探针位置或光照贴图的纹素的辐射度投影到球谐函数上，就可以进行球谐查找了(lookup)。通过与系数的点积等一些计算就可以得到球面上任意方向的辐射度，就可以在空间中得到像《半条命2》中使用反射率贴图和法线贴图与正交基函数计算获得变化的效果。 事实证明，用球谐函数从入射辐照亮度计算辐射度很有用，因为球谐函数表示低频信号是很高效的，在频域中进行简单的乘法就可以完成卷积。在空间域中，与立方体贴图的卷积是$n^{2}$的运算，包含来自辐射率立方体贴图的很多样本。 因此球谐函数近似于辐射度，并且可以在运行时将辐射率转化为辐射度。在探针或光照贴图中存储辐射率的近似值而不是辐射率的近似值(虽然是模糊的版本)，这样的低频信号与镜面反射BRDF的乘积进行积分来得到镜面反射。如果用球谐函数近似辐射度，那么也需要用球谐函数近似BRDF。 然而基于微平面理论的BRDF比兰伯特漫反射BRDF复杂得多。对于漫反射光照，无论材质和观察方向如何，余弦波瓣都是相同的。但是镜面波瓣根据观察方向、材质的粗糙度以及F0的菲尼尔项的不同而变化。本来使用查找表(lookup table,LUT)需要四个参数(观察方向是二维的)，但《光环3》中针对球谐函数镜面反射提出了更好的方法。当视线沿着局部Z轴(面法线)旋转时，镜面波瓣的形状不会变化，只有当视线与局部Z轴的夹角发生改变时波瓣形状才会改变。因此可以按局部X轴的所有视线方向预计算系数，这样产生的波瓣与实际的观察方向就可以对齐，如图所示： 下图展示了计算L2球谐函数光照贴图得到的间接镜面反射项。 使用球谐函数的方法有个常见的问题——“Ringing”现象。当一侧有强光时，在另一侧就会产生负的波瓣，其值就会非常低甚至是赋值。对于2D光照贴图不是大问题，因为光照贴图只与面法线的半球入射辐率有关。但对于存储了整个球体的辐射率或辐射度的探针来讲就会有问题。Peter-Pike Sloan提出了一个解决方案，将窗口函数(windowing function)应用于球谐函数的系数，过滤掉Ringing现象，但窗口函数会引入额外的模糊。下图分别展示了蒙特卡洛积分离线渲染结果、投影辐射率到L2球谐函数并计算辐射度产生Ringing现象、应用窗口函数后的效果修正。","categories":[{"name":"图形学","slug":"图形学","permalink":"https://cuihongzhi1991.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"球面高斯","slug":"球面高斯","permalink":"https://cuihongzhi1991.github.io/tags/%E7%90%83%E9%9D%A2%E9%AB%98%E6%96%AF/"},{"name":"光照贴图","slug":"光照贴图","permalink":"https://cuihongzhi1991.github.io/tags/%E5%85%89%E7%85%A7%E8%B4%B4%E5%9B%BE/"},{"name":"图形学","slug":"图形学","permalink":"https://cuihongzhi1991.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"UE4使用插件创建Global Shader","slug":"ueglobalshader","date":"2020-04-28T14:19:15.000Z","updated":"2020-04-28T14:51:23.876Z","comments":true,"path":"2020/04/28/ueglobalshader/","link":"","permalink":"https://cuihongzhi1991.github.io/2020/04/28/ueglobalshader/","excerpt":"UE4的Global Shader在很久之前的版本就有了，并且底层的渲染管线也是使用Global Shader渲染Light Shaft、Volumetric Fog等等。而且由于版本的更迭，很多设置参数的方式和调用的函数都渐渐改变。虽然旧的一些特性依然使用原来的方式，但新的一些特性如4.24的大气系统都开始使用新的方式。本文记录的就是4.24版本使用较新的方式设置参数，传递参数以及调用函数的方法。","text":"UE4的Global Shader在很久之前的版本就有了，并且底层的渲染管线也是使用Global Shader渲染Light Shaft、Volumetric Fog等等。而且由于版本的更迭，很多设置参数的方式和调用的函数都渐渐改变。虽然旧的一些特性依然使用原来的方式，但新的一些特性如4.24的大气系统都开始使用新的方式。本文记录的就是4.24版本使用较新的方式设置参数，传递参数以及调用函数的方法。 创建插件使用UE4.24版本创建空插件模板，命名CustomGlobalShader。 之后会将渲染逻辑和游戏逻辑分别写在两个模块中，CustomGlobalShader.uplugin中填写需要加载的模块。 为两个模块分别创建两个文件夹，并且创建Shaders文件夹作为shader路径 ShaderDeclaration模块创建模块首先修改.Build.cs文件，添加依赖的模块，如Renderer, RendererCore, RHI和Projects。123456789101112using UnrealBuildTool;public class ShaderDeclaration : ModuleRules&#123; public ShaderDeclaration(ReadOnlyTargetRules Target) : base(Target) &#123; PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs; PrivateDependencyModuleNames.AddRange( new string[] &#123; \"Core\", \"CoreUObject\", \"Engine\", \"Renderer\", \"RenderCore\", \"RHI\", \"Projects\" &#125;); &#125;&#125; ShaderDeclaration.h因为在插件中已经有了模块接口，直接用它与Renderer交互即可。并且提供了将游戏模块与渲染hook解耦的优点，允许更安全和简单的清理。随着4.22的到来，API中可以看到Renderer被大改成更现代的使用方式，就像DX12一样。最大的区别是现在必须将渲染代码封装到一个Render Graph或者Render Pass中。两者各有优点。 Render graphs在UE4中，如果要处理较大的渲染作业并使用引擎池的渲染目标，通常会使用graph。由于引擎现在为了渲染任务专门使用任务graph。使用前从案例中学习也是更简单正确的方式。然而与UObject渲染资源（如Utextures）交互时就非常难用，所以可以使用Render pass来代替。graph通常在应对大体量作业时比较好，对于小规模的作业可以使用Render pass。 Render passesPasses与之前的图形API类似，现在使用光栅化的时候会使用Pass。现在可以创建一个渲染Pass，而不是为光栅化操作设置渲染目标。不使用光栅化的操作（如计算、拷贝和其他操作）可以像之前一样直接使用RHICommandList。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#pragma once#include \"CoreMinimal.h\"#include \"Modules/ModuleManager.h\"#include \"Runtime/Engine/Classes/Engine/TextureRenderTarget2D.h\" // UTextureRenderTarget2D#include \"RenderGraphResources.h\" // IPooledRenderTargetstruct FShaderUsageParameters&#123; UTextureRenderTarget2D* RenderTarget; FColor InputColor; FIntPoint GetRenderTargetSize() const &#123; return CachedRenderTargetSize; &#125; FShaderUsageParameters() &#123;&#125; FShaderUsageParameters(UTextureRenderTarget2D* InRenderTarget) : RenderTarget(InRenderTarget) , InputColor(FColor::White) &#123; CachedRenderTargetSize = RenderTarget ? FIntPoint(RenderTarget-&gt;SizeX, RenderTarget-&gt;SizeY) : FIntPoint::ZeroValue; &#125;private: FIntPoint CachedRenderTargetSize;&#125;;class SHADERDECLARATION_API FShaderDeclarationModule : public IModuleInterface&#123;public: static inline FShaderDeclarationModule&amp; Get() &#123; return FModuleManager::LoadModuleChecked&lt;FShaderDeclarationModule&gt;(\"ShaderDeclaration\"); &#125; static inline bool IsAvailable() &#123; return FModuleManager::Get().IsModuleLoaded(\"ShaderDeclaration\"); &#125; virtual void StartupModule() override; virtual void ShutdownModule() override;public: // 想hook renderer开始渲染时可以调用该方法。每帧都会执行着色器。 void BeginRendering(); // 结束时，调用停止绘制函数 void EndRendering(); // 需要分享新参数时就调用该方法。可以在保存locking和GPU传输时的不同间隙设置它来更新不同的属性集 void UpdateParameters(FShaderUsageParameters&amp; DrawParameters);private: TRefCountPtr&lt;IPooledRenderTarget&gt; UserRenderTarget; FShaderUsageParameters CachedShaderUsageParameters; FDelegateHandle OnPostResolvedSceneColorHanndle; FCriticalSection RenderEveryFrameLock; volatile bool bCachedParametersValid; void PostResolveSceneColor_RenderThread(FRHICommandListImmediate&amp; RHICmdList, class FSceneRenderTargets&amp; SceneContext); void Draw_RenderThread(const FShaderUsageParameters&amp; DrawParameters);&#125;; ShaderDeclaration.cpp游戏线程会调用以下的方法，开始渲染、停止渲染、更新参数等等。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include \"ShaderDeclaration.h\"#include \"SimpleColor.h\"#include \"Misc/Paths.h\" // FPath#include \"Interfaces/IPluginManager.h\" // IPluginManager#include \"RenderGraphBuilder.h\" // Debug stat macro#include \"RenderTargetPool.h\" // GRenderTargetPoolIMPLEMENT_MODULE(FShaderDeclarationModule, ShaderDeclaration)// 声明一些GPU统计数据，后续方便追踪DECLARE_GPU_STAT_NAMED(GlobalShaderPlugin_Render, TEXT(\"GlobalShaderPlugin: Root Render\"));DECLARE_GPU_STAT_NAMED(GlobalShaderPlugin_Pixel, TEXT(\"GlobalShaderPlugin: Render Pixel Shader\"));void FShaderDeclarationModule::StartupModule()&#123; OnPostResolvedSceneColorHanndle.Reset(); bCachedParametersValid = false; // 映射虚拟的着色器资源路径到插件实际的着色器路径 FString GlobalShaderDir = FPaths::Combine(IPluginManager::Get().FindPlugin(TEXT(\"CustomGlobalShader\"))-&gt;GetBaseDir(), TEXT(\"Shaders\")); AddShaderSourceDirectoryMapping(TEXT(\"/CustomShaders\"), GlobalShaderDir);&#125;void FShaderDeclarationModule::ShutdownModule()&#123; EndRendering();&#125;void FShaderDeclarationModule::BeginRendering()&#123; if (OnPostResolvedSceneColorHanndle.IsValid()) &#123; return; &#125; bCachedParametersValid = false; // 获取Renderer模块 const FName RendererModuleName(\"Renderer\"); IRendererModule* RendererModule = FModuleManager::GetModulePtr&lt;IRendererModule&gt;(RendererModuleName); if (RendererModule) &#123; OnPostResolvedSceneColorHanndle = RendererModule-&gt;GetResolvedSceneColorCallbacks().AddRaw(this, &amp;FShaderDeclarationModule::PostResolveSceneColor_RenderThread); &#125;&#125;void FShaderDeclarationModule::EndRendering()&#123; if (!OnPostResolvedSceneColorHanndle.IsValid()) &#123; return; &#125; const FName RendererModuleName(\"Renderer\"); IRendererModule* RendererModule = FModuleManager::GetModulePtr&lt;IRendererModule&gt;(RendererModuleName); if (RendererModule) &#123; RendererModule-&gt;GetResolvedSceneColorCallbacks().Remove(OnPostResolvedSceneColorHanndle); &#125; OnPostResolvedSceneColorHanndle.Reset();&#125;void FShaderDeclarationModule::UpdateParameters(FShaderUsageParameters&amp; DrawParameters)&#123; RenderEveryFrameLock.Lock(); CachedShaderUsageParameters = DrawParameters; bCachedParametersValid = true; RenderEveryFrameLock.Unlock();&#125;void FShaderDeclarationModule::PostResolveSceneColor_RenderThread(FRHICommandListImmediate&amp; RHICmdList, class FSceneRenderTargets&amp; SceneContext)&#123; if (!bCachedParametersValid) &#123; return; &#125; // 根据数据可以选择是否锁，添加此代码只是为了演示如何锁 RenderEveryFrameLock.Lock(); FShaderUsageParameters Copy = CachedShaderUsageParameters; RenderEveryFrameLock.Unlock(); Draw_RenderThread(Copy);&#125;void FShaderDeclarationModule::Draw_RenderThread(const FShaderUsageParameters&amp; DrawParameters)&#123; check(IsInRenderingThread()); if (!DrawParameters.RenderTarget) &#123; return; &#125; FRHICommandListImmediate&amp; RHICmdList = GRHICommandList.GetImmediateCommandList(); QUICK_SCOPE_CYCLE_COUNTER(STAT_GlobalShaderPlugin_Render); // 为UE4前端收集CPU分析数据 SCOPED_DRAW_EVENT(RHICmdList, GlobalShaderPlugin_Render); // 为分析GPU活动添加的元数据，可以用RenderDoc这种工具查看 if (!UserRenderTarget.IsValid()) &#123; // 创建缓存RT描述符，FPooledRenderTarget是渲染线程允许共享和纹理可视化的渲染目标。 FPooledRenderTargetDesc UserRenderTargetDesc(FPooledRenderTargetDesc::Create2DDesc(DrawParameters.GetRenderTargetSize(), PF_R32_UINT, FClearValueBinding::None, TexCreate_None, TexCreate_ShaderResource | TexCreate_UAV, false)); UserRenderTargetDesc.DebugName = TEXT(\"GlobalShaderPlugin_UserRenderTarget\"); // 如果旧元素依然有效则返回true, 分配了新元素则返回false GRenderTargetPool.FindFreeElement(RHICmdList, UserRenderTargetDesc, UserRenderTarget, TEXT(\"GlobalShaderPlugin_UserRenderTarget\")); &#125; FSimpleColor::DrawToRenderTarget_RenderThread(RHICmdList, DrawParameters, UserRenderTarget-&gt;GetRenderTargetItem().TargetableTexture);&#125; SimpleColor.h声明一个简单着色器的绘制函数12345678910#pragma once#include \"CoreMinimal.h\"#include \"ShaderDeclaration.h\"class FSimpleColor&#123;public: static void DrawToRenderTarget_RenderThread(FRHICommandListImmediate&amp; RHICmdList, const FShaderUsageParameters&amp; DrawParameters, FTextureRHIRef UserRenderTarget);&#125;; SimpleColor.cpp此处会创建两个Global Shader，分别是顶点着色器和像素着色器。并且通过IMPLEMENT_GLOBAL_SHADER()进行绑定。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include \"SimpleColor.h\"#include \"Containers/DynamicRHIResourceArray.h\" // TResourceArray#include \"Runtime/RenderCore/Public/PixelShaderUtils.h\" // FFilterVertex// 基础的静态顶点缓冲class FSimpleScreenVertexBuffer : public FVertexBuffer&#123;public: // 为渲染资源初始化RHI void InitRHI() &#123; // FFilterVertex 表示顶点数据是用来过滤纹理的， VERTEXBUFFER_ALIGNMENT 是内存分配时的对齐方式 TResourceArray&lt;FFilterVertex, VERTEXBUFFER_ALIGNMENT&gt; Vertices; Vertices.SetNumUninitialized(6); Vertices[0].Position = FVector4(-1, 1, 0, 1); Vertices[0].UV = FVector2D(0, 0); Vertices[1].Position = FVector4(1, 1, 0, 1); Vertices[1].UV = FVector2D(1, 0); Vertices[2].Position = FVector4(-1, -1, 0, 1); Vertices[2].UV = FVector2D(0, 1); Vertices[3].Position = FVector4(1, -1, 0, 1); Vertices[3].UV = FVector2D(1, 1); // 创建顶点缓冲区， 用上方创建的初始数据填充该缓冲 FRHIResourceCreateInfo CreateInfo(&amp;Vertices); VertexBufferRHI = RHICreateVertexBuffer(Vertices.GetResourceDataSize(), BUF_Static, CreateInfo); &#125;&#125;;// 声明一个顶点缓冲TGlobalResource&lt;FSimpleScreenVertexBuffer&gt; GSimpleScreenVertexBuffer;// 基础的顶点着色器class FSimpleColorVS : public FGlobalShader&#123;public: DECLARE_GLOBAL_SHADER(FSimpleColorVS); static bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters&amp; Parameters) &#123; return true; &#125; static void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters&amp; Parameters, FShaderCompilerEnvironment&amp; OutEnvironment) &#123; FGlobalShader::ModifyCompilationEnvironment(Parameters, OutEnvironment); &#125; FSimpleColorVS() &#123;&#125; FSimpleColorVS(const ShaderMetaType::CompiledShaderInitializerType&amp; Initializer) : FGlobalShader(Initializer) &#123;&#125;&#125;;// 像素着色器，参数作为cpp和HLSL的桥梁class FSimpleColorPS : public FGlobalShader&#123;public: DECLARE_GLOBAL_SHADER(FSimpleColorPS); SHADER_USE_PARAMETER_STRUCT(FSimpleColorPS, FGlobalShader); // 和游戏线程的参数一一对应 BEGIN_SHADER_PARAMETER_STRUCT(FParameters,) SHADER_PARAMETER(FVector4, InputColor) END_SHADER_PARAMETER_STRUCT() static bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters&amp; Parameters) &#123; return IsFeatureLevelSupported(Parameters.Platform, ERHIFeatureLevel::SM5); &#125; static void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters&amp; Parameters, FShaderCompilerEnvironment&amp; OutEnvironment) &#123; FGlobalShader::ModifyCompilationEnvironment(Parameters, OutEnvironment); &#125;&#125;;// 告诉引擎创建着色器以及着色器的入口位置 // 着色器类型 着色器路径 着色器函数名 类型IMPLEMENT_GLOBAL_SHADER(FSimpleColorVS, \"/CustomShaders/PixelShader.usf\", \"MainVertexShader\", SF_Vertex);IMPLEMENT_GLOBAL_SHADER(FSimpleColorPS, \"/CustomShaders/PixelShader.usf\", \"MainPixelShader\", SF_Pixel);void FSimpleColor::DrawToRenderTarget_RenderThread(FRHICommandListImmediate&amp; RHICmdList, const FShaderUsageParameters&amp; DrawParameters, FTextureRHIRef UserRenderTarget)&#123; QUICK_SCOPE_CYCLE_COUNTER(STAT_CustomGlobalShaderPlugin_PixelShader); // 为UE4前端收集CPU分析数据 SCOPED_DRAW_EVENT(RHICmdList, CustomGlobalShaderPlugin_Pixel); // 为分析GPU活动添加的元数据，可以用RenderDoc这种工具查看 FRHIRenderPassInfo RenderPassInfo(DrawParameters.RenderTarget-&gt;GetRenderTargetResource()-&gt;GetRenderTargetTexture(), ERenderTargetActions::Clear_Store); RHICmdList.BeginRenderPass(RenderPassInfo, TEXT(\"CustomGlobalShaderPlugin_OutputToRenderTarget\")); auto ShaderMap = GetGlobalShaderMap(GMaxRHIFeatureLevel); TShaderMapRef&lt;FSimpleColorVS&gt; VertexShader(ShaderMap); TShaderMapRef&lt;FSimpleColorPS&gt; PixelShader(ShaderMap); // 设置图形管线状态 FGraphicsPipelineStateInitializer GraphicsPSOInit; RHICmdList.ApplyCachedRenderTargets(GraphicsPSOInit); GraphicsPSOInit.BlendState = TStaticBlendState&lt;&gt;::GetRHI(); GraphicsPSOInit.RasterizerState = TStaticRasterizerState&lt;&gt;::GetRHI(); GraphicsPSOInit.DepthStencilState = TStaticDepthStencilState&lt;false, CF_Always&gt;::GetRHI(); GraphicsPSOInit.BoundShaderState.VertexDeclarationRHI = GFilterVertexDeclaration.VertexDeclarationRHI; GraphicsPSOInit.BoundShaderState.VertexShaderRHI = GETSAFERHISHADER_VERTEX(*VertexShader); GraphicsPSOInit.BoundShaderState.PixelShaderRHI = GETSAFERHISHADER_PIXEL(*PixelShader); GraphicsPSOInit.PrimitiveType = PT_TriangleStrip; SetGraphicsPipelineState(RHICmdList, GraphicsPSOInit); // 设置像素着色器颜色，将游戏线程的参数传进来 FSimpleColorPS::FParameters PassParameters; PassParameters.InputColor = FVector4(DrawParameters.InputColor.R, DrawParameters.InputColor.G, DrawParameters.InputColor.B, DrawParameters.InputColor.A) / 255.0f; // 提交参数到RHI命令列表 SetShaderParameters(RHICmdList, *PixelShader, PixelShader-&gt;GetPixelShader(), PassParameters); // 绘制 RHICmdList.SetStreamSource(0, GSimpleScreenVertexBuffer.VertexBufferRHI, 0); RHICmdList.DrawPrimitive(0, 2, 1); // 完成渲染目标 RHICmdList.CopyToResolveTarget(DrawParameters.RenderTarget-&gt;GetRenderTargetResource()-&gt;GetRenderTargetTexture(), DrawParameters.RenderTarget-&gt;GetRenderTargetResource()-&gt;TextureRHI, FResolveParams()); RHICmdList.EndRenderPass();&#125; PixelShader.usf着色器的声明模块基本结束。需要创建与之对应的着色器文件.usf放在Shaders文件夹。1234567891011121314// VERTEX SHADERvoid MainVertexShader(float4 InPosition : ATTRIBUTE0, float2 InUV : ATTRIBUTE1, out float2 OutUV : TEXCOORD0, out float4 OutPosition : SV_POSITION)&#123; OutPosition = InPosition; OutUV = InUV;&#125;// PIXEL SHADERfloat4 InputColor;void MainPixelShader(in float2 uv : TEXCOORD0, out float4 OutColor : SV_Target0)&#123; OutColor = InputColor;&#125; 着色器应用模块创建模块首先修改.Build.cs文件，添加依赖的模块，如上面创建的ShaderDeclaration12345678910111213using UnrealBuildTool;public class ShaderUsage : ModuleRules&#123; public ShaderUsage(ReadOnlyTargetRules Target) : base(Target) &#123; PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs; PublicDependencyModuleNames.AddRange( new string[] &#123; \"Core\", \"CoreUObject\", \"Engine\", \"RHI\", \"ShaderDeclaration\" &#125;); &#125;&#125; ShaderUsage.h基本的模块功能。123456789101112131415161718#pragma once#include \"CoreMinimal.h\"#include \"Modules/ModuleManager.h\"class FShaderUsageModule : public IModuleInterface&#123;public: static inline FShaderUsageModule&amp; Get() &#123; return FModuleManager::LoadModuleChecked&lt;FShaderUsageModule&gt;(\"ShaderUsage\"); &#125; static inline bool IsAvailable() &#123; return FModuleManager::Get().IsModuleLoaded(\"ShaderUsage\"); &#125;&#125;; ShaderUsage.cpp123#include \"ShaderUsage.h\"IMPLEMENT_MODULE(FShaderUsageModule, ShaderUsage) TestActor.h创建一个测试Actor类。123456789101112131415161718192021#pragma once#include \"CoreMinimal.h\"#include \"GameFramework/Actor.h\"#include \"TestActor.generated.h\"UCLASS()class ATestActor : public AActor&#123; GENERATED_BODY()public: UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = GlobalShader) FColor InputColor; UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = GlobalShader) class UTextureRenderTarget2D* UserRenderTarget;public: virtual void BeginPlay() override; virtual void BeginDestroy() override; virtual void Tick(float DeltaTime) override;&#125;; TestActor.cpp1234567891011121314151617181920212223242526#include \"TestActor.h\"#include \"ShaderDeclaration.h\"void ATestActor::BeginPlay()&#123; Super::BeginPlay(); FShaderDeclarationModule::Get().BeginRendering();&#125;void ATestActor::BeginDestroy()&#123; FShaderDeclarationModule::Get().EndRendering(); Super::BeginDestroy();&#125;void ATestActor::Tick(float DeltaTime)&#123; Super::Tick(DeltaTime); FShaderUsageParameters DrawParameters(UserRenderTarget); &#123; DrawParameters.InputColor = InputColor; &#125; FShaderDeclarationModule::Get().UpdateParameters(DrawParameters);&#125; 目前应用模块也已经完成，编译完成后，在引擎中测试效果。 测试结果首先以TestActor为父类创建蓝图类。然后创建一个RT，和一个使用该RT的材质。蓝图类中添加一个Box，并使用该测试材质。EventTick每帧传入随机的颜色，Play一下便可以看到颜色不断变化的Box了。","categories":[{"name":"Unreal Engine","slug":"Unreal-Engine","permalink":"https://cuihongzhi1991.github.io/categories/Unreal-Engine/"}],"tags":[{"name":"UE4","slug":"UE4","permalink":"https://cuihongzhi1991.github.io/tags/UE4/"},{"name":"材质","slug":"材质","permalink":"https://cuihongzhi1991.github.io/tags/%E6%9D%90%E8%B4%A8/"},{"name":"渲染管线","slug":"渲染管线","permalink":"https://cuihongzhi1991.github.io/tags/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"}]},{"title":"UE4.22+ 添加自定义卡通着色模型","slug":"ue4addshadingmodel","date":"2020-04-25T06:14:25.000Z","updated":"2020-04-28T13:19:35.113Z","comments":true,"path":"2020/04/25/ue4addshadingmodel/","link":"","permalink":"https://cuihongzhi1991.github.io/2020/04/25/ue4addshadingmodel/","excerpt":"UE4中内置了一些着色模型(Shading Model)，基本满足了绝大部分游戏开发的需求。但一些特殊美术风格的游戏也许需要自定义着色模型，比如当下火热的二次元向游戏。本文记录了4.22+版本添加自定义着色模型的方法。","text":"UE4中内置了一些着色模型(Shading Model)，基本满足了绝大部分游戏开发的需求。但一些特殊美术风格的游戏也许需要自定义着色模型，比如当下火热的二次元向游戏。本文记录了4.22+版本添加自定义着色模型的方法。 创建自定义着色模型添加着色模型类型在EngineTypes.h中为自定义的着色模型添加一个新的UENUM。MaterialShader.cpp 添加一个枚举只是可以在材质编辑器看到而已，必须要定义这个着色模型。首先要设置编译这个着色器的环境。通过SetDefine()实现。SetDefine()函数的作用是为着色器添加一个属性的#define预处理器，编译着色器时就知道按照何种着色模型去编译。下面的代码就会让着色器编译器将MATERIAL_SHADINGMODEL_CEL_SHADING认作1.HLSLMaterialTranslator.h 开启材质引脚将会使用CustomData0和1作为Cel Bands和Outline Thickness的引脚。只需要在Material.cpp中的MP_CustomData0和MP_CustomData1之后添加开启条件。 CustomData可以保持CustomData0或1的引脚名称，也可以自定义名字。在MaterialGraph.cpp中的GetCustomDataPinName()中添加着色模型对应的引脚名称。 另外CustomData0和1的范围是0到1，所以大于1的数值n操作最好用1/n做后续数学计算。可以在AllocGBufferTargets()函数中看到UE4使用的是B8G8R8A8存储GBuffer的，CustomData的数据是储存在R或G通达的，8-bit小数最大值会被限制1.0。 借Refraction的引脚修改case MP_Refraction引脚的激活条件。 但是编译材质图标节点到着色器代码时，UE会检查冗余和不持支的内容，不支持的部分就会丢弃掉，或者被默认值代替。在HLSLMaterialTranslator.h的Translate()中，Refraction引脚只有混合模式为半透的时候才会编译，所以修改一下编译条件。 在MaterialGraph.cpp的RebuildGraph()函数中可以修改Refraction引脚名称的实现方式，用GetRefractionPinName()函数获取最终名称。 现在已经修改好所有的cpp和h文件,可以编译引擎工程。 修改着色器：BasePass和GBuffer建立着色模型ID和颜色在ShadingCommon.ush中定义新的SHADINGMODELID，并设置ID和颜色 为了让GBuffer输出CustomData，需要在BasePassCommon.ush中扩展输出条件 输出GBuffer数据的准备工作ShadingModelsMaterial.ush中的SetGBufferForShadingModel()函数会设置GBuffer的数据，添加Cel着色模型的情况。 但是Refraction引脚的数据需要用GetMaterialRefraction(FPixelMaterialInputs PixelMaterialInputs)，可以在BasePassPixelShader.ush中使用PixelMaterialInpus输入参数得到Refraction引脚的数据。 修改着色器：DeferredPass和Lighting光照调整DeferredLightPixelMain()函数在DeferredLightPixelShaders.usf中。颜色是通过GetDynamicLighting()函数实现的，该函数位于DeferredLightingCommon.ush中。首先获取阴影项，然后调用函数IntegrateBxDF()函数得到光照项。在该函数中，不同的着色模型会执行不同的BxDF()，所以可以在ShadingModels.ush的IntegratedBxDF()函数中添加CelShadingBxDF()。可以以DefaultLitBxDF()为基础修改和扩展。 阴影调整阴影还是默认的柔和，在GetDynamicLighting()中的IntegrateBxDF()前调用了GetShadowTerms()。在计算光照颜色的时候将LightColor与LightMask和Shadow.SurfaceShadow进行了相乘。所以只需要对LightMask和Shadow.SurfaceShadow进行一步处理，得到分层的锐利阴影即可。DeferredLightingCommon.ush 反射调整在ReflectionEnvironmentPixelShader.ush文件中加入判断条件，如果是卡通着色模型，就转为LAB格式调整亮度再转回RGB。 描边因为是延迟渲染，所以可以在延迟光照的步骤可以拿到深度和法线做描边。 修改代码在DeferredLightPixelShaders.usf的DeferredLightPixelMain()中添加函数CalcSceneDepth()。SceneTexturesStruct包含了GBufferA/B/C/DTexture，场景深度就在其中。法线存在GBufferA。","categories":[{"name":"Unreal Engine","slug":"Unreal-Engine","permalink":"https://cuihongzhi1991.github.io/categories/Unreal-Engine/"}],"tags":[{"name":"UE4","slug":"UE4","permalink":"https://cuihongzhi1991.github.io/tags/UE4/"},{"name":"材质","slug":"材质","permalink":"https://cuihongzhi1991.github.io/tags/%E6%9D%90%E8%B4%A8/"},{"name":"卡通着色","slug":"卡通着色","permalink":"https://cuihongzhi1991.github.io/tags/%E5%8D%A1%E9%80%9A%E7%9D%80%E8%89%B2/"},{"name":"渲染管线","slug":"渲染管线","permalink":"https://cuihongzhi1991.github.io/tags/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"}]},{"title":"UE4.22+ 添加Uniform","slug":"ue4uniform","date":"2020-04-23T05:10:39.000Z","updated":"2020-04-28T13:19:40.526Z","comments":true,"path":"2020/04/23/ue4uniform/","link":"","permalink":"https://cuihongzhi1991.github.io/2020/04/23/ue4uniform/","excerpt":"Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式，Uniform是全局的(Global)。全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。第二，无论你把Uniform值设置成什么，Uniform会一直保存它们的数据，直到它们被重置或更新。UE4的材质编辑器可以调用的红色节点中很多就是Uniform，如ObjectBounds，ActorPosition等等。本文记录了如何在UE4.22或更高版本添加自定义的Uniform，并且生成材质节点在任意材质中调用，该Uniform值也将显示在场景的Skylight组件上供用户修改。","text":"Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式，Uniform是全局的(Global)。全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。第二，无论你把Uniform值设置成什么，Uniform会一直保存它们的数据，直到它们被重置或更新。UE4的材质编辑器可以调用的红色节点中很多就是Uniform，如ObjectBounds，ActorPosition等等。本文记录了如何在UE4.22或更高版本添加自定义的Uniform，并且生成材质节点在任意材质中调用，该Uniform值也将显示在场景的Skylight组件上供用户修改。 创建CPU中的数据结构体FShaderParametersMetadata这是一个4.22的新类，4.21有一个类似的结构体FUniformBufferStruct。4.22中可以在ShaderParameterMetadata.h中找到这个类。FShaderParametersMetadata是一个储存了多个着色器参数的集合或容器。该容器可以储存不同数据类型的参数。每个参数都是一个成员，可以是矩阵、向量、数组或者纹理。（提示：FShaderParameter.h中还定义了另外一个着色器参数系统。有FShaderParameter, FShaderResourceParameter, FShaderUniformBufferParameter等等。依然可以在单独的着色器中使用，如在LightRendering.cpp中一样。）如果要定义一组着色器参数，可以用宏来声明这些元数据，这是将它们放进UniformBuffer的快捷办法。 ShaderParameterMacros.h这个头文件中包含了一些声明参数结构体的宏。比如BEGIN_GLOBAL_SHADER_PARAMETER_STRUCT()和END_GLOBAL_SHADER_PARAMETER_STRUCT()。这两个宏创建了一个类作为ParameterMetadata的壳，如：123456789// Begin Macro:class STRUCT_NAME &#123;static Metadata;CreateUniformBuffer() (when declare as GLOBAL)...Parameter Macro: Insert all members (Parameter)...// End:some ending stuff + &#125;对于全局的参数结构体，cpp中需要添加另外一个宏： IMPLEMENT_GLOBAL_SHADER_PARAMETER_STRUCT(FMyParameterStruct, “MyShaderBindingName”);这个宏将静态的元数据放入一个全局的容器，扩展后的宏类似下方：12FShaderParametersMetadata StructTypeName::Metadata(...);=&gt; FShaderParametersMetadata(..) &#123; Add-Self-To-Global-Container &#125;现在有了元数据的壳，可以开始使用SHADER_PARAMETER(Type, Name) 添加一些参数到壳中，用类型和名称创建一个成员，然后添加该成员到元数据的成员数组中。（提示：有两个版本的声明：GLOBAL和LOCAL，区别是GLOBAL会在类中创建一个UniformBuffer并且所有成员会放进这个缓冲中，另外GLOBAL会将元数据保存在全局的map和list中。而LOCAL方式不会创建内在的UniformBuffer，所以不用调用IMPLEMENT_宏。) 案例：Primitive Uniform, View Uniform可以参考一下PrimitiveUniform和ViewUniform，两个最重要的UniformShaderParameters。 PrimitiveUniformShaderParameters.h该头文件中声明了一个FPrimitiveUniformShaderParameters的结构体。之所以比较重要是因为在检索着色器代码的时候经常会看到”Primitive”或”GetPrimitiveData()“这样的变量，都是来自这个uniform结构体的。它保存了一个图元（或图元组件）的信息，包括LocalToWorld, WorldToLocal等等。 FViewUniformShaderParameters(SceneView.h)可以认为这是当前视图相关的场景信息，包括相机的信息，游戏时间或者其他渲染需要的信息。这也是一个适合添加自定义全局Uniform参数的地方。在这个ShaderParameters中， 4.22加入了StructuredBuffer类型，可以传递数组进StructuredBuffer，名称为PrimitiveSceneData的Buffer包含所有GPU实例化的图元数据。 IMPLEMENT_Macro(SceneView.cpp)上文提到过，实现宏创建元数据并且保存到全局的容器中。另外，这个宏也会帮助着色器编译器为GPU生成着色器代码。例如着色器编译器会生成一个”cbuffer Primitive{}”和”cbuffer View{}”，名称是传进宏里的名称。cbuffer的内容也是从FPrimitiveUniformShaderParameters或FViewUniformShaderParameters反射的。 （提示：当不支持自动实例化时，就会使用cubuffer Primitive，因此每个Drawcall现在的图元会绑定它的UniformBuffer到cbuffer。当自动实例化开启是，就不使用这个cbuffer了，而是使用ViewUniform中的StructuredArray”PrimitiveSceneData” 。） GPU：生成着色器代码之前讨论过，cbuffer结构中的着色器代码在任何.ush文件中都没有预先定义，它们是在编译着色器的时候生成的。下面大致看下原理。1234567891011121314151617181920212223242526272829303132333435363738394041//////////////////////// ShaderCompiler.cpp//////////////////////void GlobalBeginCompileShader(…)&#123; … // 设置编译标识，添加任务到队列，编译器稍后会调用该任务 NewJobs.Add(NewJob);&#125;//////////////////////////// ShaderCompileWorker.cpp//////////////////////////static void ProcessCompilationJob(…)&#123; ... // 调用ShaderFormatD3D.cpp::CompileShader() (D3D) Compiler-&gt;CompileShader(…);&#125;////////////////////////// D3DShaderCompiler.cpp////////////////////////void CompileShader_Windows_SM5(…)&#123; … CompileD3DShader(…);&#125;void CompileD3DShader(…)&#123; … if (Input.RootParameterBindings.Num()) &#123; // 生成全局ShaderParameters的cbuffer代码，将字符串放在PreprocessedShaderSource中 MoveShaderParametersToRootConstantBuffer(Input, PreprocessedShaderSource); &#125; // 处理字符串：修改代码便于从\"cbuffer.memberData\"到\"cbuffer_memberData\"的代码允许cbuffer访问。 RemoveUniformBuffersFromSource(Input.Environment, PreprocessedShaderSource); …&#125;着色器代码是在MoveShaderParametersToRootConstantBuffer()中生成的，然后RemoveUniformBuffersFromSource()会对着色器代码进行调整。[cbuffer_name].[dataMember]会转化成[cbuffer_name]_[dataMember]，例如View.LocalToWorld会变成View_LocalToWorld。 1234567891011121314151617181920212223242526// ShaderCompilerCommon.cpp:void MoveShaderParametersToRootConstantBuffer(…)&#123; … /* Print the string \"cbuffer &#123;…&#125;\" , but looks like this is still an intermediate code, the string will be proccessed later again, but I don't trace too much in this part */ // 输出字符串\"cbuffer&#123;...&#125;\", 但貌似只是过渡，后面字符串还会被处理一次。 FString NewShaderCode = FString::Printf( TEXT(\"cbuffer %s\\r\\n\") TEXT(\"&#123;\\r\\n\") TEXT(\"%s\") TEXT(\"&#125;\\r\\n\\r\\n%s\"), FShaderParametersMetadata::kRootUniformBufferBindingName, *RootCBufferContent, *PreprocessedShaderSource); PreprocessedShaderSource = MoveTemp(NewShaderCode);&#125;// 交叉编译器还不支持结构体初始化，用名称替换所有的uniform缓冲结构体成员的引用。// 例如View.WorldToClip变成View_WorldToClip，移除结构体的依赖。void RemoveUniformBuffersFromSource(…)&#123; … /* 'OpaqueBasePass.Shared.Reflection .SkyLightCubemapBrightness' -&gt; 'OpaqueBasePass_Shared_Reflection_SkyLightCubemapBrightness ' */ …&#125; 生成的着色器代码下方的两个文件在vs中是找不到的，因为它们是在编译时自动生成的。但是，可以修改着色器编译器设置来显示debug信息。在ConsoleVariables.ini中添加r.Shaders.Optimize=0和r.Shaders.KeepDebugInfo=1。然后就可以用RenderDoc抓帧查看资源包括着色器代码。在View.ush和Primitive.ush中，可以看到cbuffer的内容与C++宏声明的着色器参数是一一对应的，而变量的前缀则是结构体的名称。 更新和绑定缓冲更新缓冲和绑定缓冲是不同的。更新需要获取参数的数据然后更新数据到UniformBuffer；绑定缓冲是告诉着色器我们将要使用哪些缓冲。例如，我们有十个UniformBuffer，它们是不同Views, Primitivies等等的缓冲，它们会在任意的drawcall前更新。但是渲染一个模型时，如果着色器只需要十个中的两个，只需要绑定其中的两个缓冲到着色器。 SceneRendering.cpp不同的uniform参数可以有自己的更新管线，所以它们可以在不同的地方更新。这里会展示一下更新ViewUniformBufferParameter的位置。从DeferredShadingRenderer.cpp::Render()可以追踪到InitViews()，最后到SceneRendering.cpp::SetupUniformBufferParameters()，此处设置了FViewUniformBufferParameter的数据。123456789/* SceneRendering.cpp */void FViewInfo::SetupUniformBufferParameters(…)&#123; … SetupCommonViewUniformBufferParameters(…); …&#125;/* SceneView.cpp */void FSceneView::SetupCommonViewUniformBufferParameters()&#123;…&#125; ClobalShader.h这是绑定缓冲的地方，同样地，不同的渲染pass可以在不同的地方绑定缓冲。发送drawcall的时候缓冲绑定几乎已经完成。因为绑定缓冲意味着链接缓冲到着色器，所以必须同时传递shaderRHI和缓冲到函数中。12345inline void SetParameters(…, ShaderRHI, ViewUniformBuffer)&#123; … SetUniformBufferParameter(…, ShaderRHI, …, ViewUniformBuffer);&#125; D3D11StateCachePrivate.hSetUniformBufferParameter()最终会来到InternalSetSetConstantBuffer()函数，这个函数会调用D3D11 API [Type]SetConstantBuffers到一个顶点/外壳/域/几何/像素/计算着色器。绑定工作在此时完成。123456D3D11_STATE_CACHE_INLINE void InternalSetSetConstantBuffer(…)&#123; … case SF_Vertex: Direct3DDeviceIMContext-&gt;VSSetConstantBuffers(…); break; …&#125; 添加Uniform控制参数添加参数因为要向View添加一个全局uniform，所以在SceneView.h添加一个VIEW_UNIFORM_BUFFER_MEMBER。 更新参数值可以借用SkyLightComponent和Proxy来存放自定义的uniform，在SetupUniformBufferParameters()中可以把用户编辑过的值传到ViewUniform。SceneRendering.cpp： 添加一个新的UPROPERTY”MyCustomClobalUniform”到SceneManagement.h 添加相应的组件变量在SkyLightSceneProxy中——“MyCustomGlobalUniform”。在代理的构造函数中，复制SkyLightComponent的值。SceneManagement.h： 在着色器代码中访问参数在.ush或.usf文件或材质编辑器的Custom节点中都可以使用View.TestConstantUniform来调用该数值了，并且可以在天光组件的参数面板中修改该数值进行全局控制。 创建材质节点添加节点类在引擎的\\Source\\Runtime\\Engine\\Classes\\Materials 路径下存放了材质编辑器的所有节点源文件。每个节点都有自己的UMaterialExpression类。所以同样在此路径创建一个头文件MaterialExpressionMyGlobalUniform.h。因为此案例只是一个向量数据，可以拷贝DeltaTime的节点。确保添加完头文件后重新生成sln，这样可以自动生成.generated.h文件，否则会编译失败。 然后在MaterialExpressions.cpp中实现它的构造函数 节点的编译器设置在MaterialCompiler.h中添加MyCustomUniform()方法。 在HLSLMaterialTranslator.h中，才是MaterialCompiler真正起作用的地方。调用AddInlinedCodeChunk(DATA_TYPE, CODE_STRING)来实现。 测试保存代码，重新成成sln工程，编译并打开引擎。","categories":[{"name":"Unreal Engine","slug":"Unreal-Engine","permalink":"https://cuihongzhi1991.github.io/categories/Unreal-Engine/"}],"tags":[{"name":"UE4","slug":"UE4","permalink":"https://cuihongzhi1991.github.io/tags/UE4/"},{"name":"材质","slug":"材质","permalink":"https://cuihongzhi1991.github.io/tags/%E6%9D%90%E8%B4%A8/"},{"name":"渲染管线","slug":"渲染管线","permalink":"https://cuihongzhi1991.github.io/tags/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"}]},{"title":"UE4.24 材质Custom节点链接.usf文件","slug":"usf424","date":"2020-04-16T14:19:15.000Z","updated":"2020-04-25T06:29:11.304Z","comments":true,"path":"2020/04/16/usf424/","link":"","permalink":"https://cuihongzhi1991.github.io/2020/04/16/usf424/","excerpt":"UE4材质编辑器中的Custom节点可以写hlsl代码，方便进行一些复杂计算，比如for循环。可以保证材质面板简洁可读性高。UE4之前的版本直接在Custom节点中用#include包含Shaders文件夹下的ush或usf文件，这样可以用外部的代码编辑器编写shader文件。但是最近的版本有所改动，Custom节点无法识别Shaders路径下的文件。所以需要修改工程模块来包含任意路径。","text":"UE4材质编辑器中的Custom节点可以写hlsl代码，方便进行一些复杂计算，比如for循环。可以保证材质面板简洁可读性高。UE4之前的版本直接在Custom节点中用#include包含Shaders文件夹下的ush或usf文件，这样可以用外部的代码编辑器编写shader文件。但是最近的版本有所改动，Custom节点无法识别Shaders路径下的文件。所以需要修改工程模块来包含任意路径。 准备工作 首先创建C++工程，如果是蓝图工程可以添加新的C++类，会自动转成C++工程。假设项目名称为MotionBlur。 修改MotionBlur.Build.cs: 12345678910111213141516using UnrealBuildTool;public class MotionBlur : ModuleRules&#123; public MotionBlur(ReadOnlyTargetRules Target) : base(Target) &#123; PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs; PublicDependencyModuleNames.AddRange(new string[] &#123; \"Core\", \"CoreUObject\", \"Engine\", \"InputCore\", // 添加依赖模块，旧版是ShaderCore,现在改为RenderCore \"RHI\", \"RenderCore\" &#125;); // 添加依赖项Projects，可以识别工程路径 PrivateDependencyModuleNames.AddRange(new string[] &#123;\"Projects\"&#125;); &#125;&#125; 修改MotionBlur.h: 123456789#pragma once#include \"CoreMinimal.h\"class FMotionBlurModule : public IModuleInterface&#123;public: virtual void StartupModule() override; virtual void ShutdownModule() override;&#125;; 修改MotionBlur.cpp: 12345678910111213141516171819#include \"MotionBlur.h\"#include \"Modules/ModuleManager.h\"#include \"Misc/Paths.h\"#include \"ShaderCore.h\"IMPLEMENT_MODULE(FMotionBlurModule, MotionBlur);void FMotionBlurModule::StartupModule() &#123; // 获取工程路径，并指定usf文件存放的路径为工程的Shaders文件夹 FString ShaderDirectory = FPaths::Combine(FPaths::ProjectDir(), TEXT(\"Shaders\")); // 路径映射Csutom节点直接写#include\"/Project/xxx.usf\"即可 AddShaderSourceDirectoryMapping(\"/Project\", ShaderDirectory);&#125;void FMotionBlurModule::ShutdownModule()&#123; ResetAllShaderSourceDirectoryMappings();&#125; 使用 函数可以放在统一的Custom节点，只有主要执行节点才可以识别输入的参数 .usf文件要放在工程路径下的Shaders文件夹（之前在CPP里自定义的路径）","categories":[{"name":"Unreal Engine","slug":"Unreal-Engine","permalink":"https://cuihongzhi1991.github.io/categories/Unreal-Engine/"}],"tags":[{"name":"UE4","slug":"UE4","permalink":"https://cuihongzhi1991.github.io/tags/UE4/"},{"name":"材质","slug":"材质","permalink":"https://cuihongzhi1991.github.io/tags/%E6%9D%90%E8%B4%A8/"}]}],"categories":[{"name":"图形学","slug":"图形学","permalink":"https://cuihongzhi1991.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"Unreal Engine","slug":"Unreal-Engine","permalink":"https://cuihongzhi1991.github.io/categories/Unreal-Engine/"}],"tags":[{"name":"球面高斯","slug":"球面高斯","permalink":"https://cuihongzhi1991.github.io/tags/%E7%90%83%E9%9D%A2%E9%AB%98%E6%96%AF/"},{"name":"光照贴图","slug":"光照贴图","permalink":"https://cuihongzhi1991.github.io/tags/%E5%85%89%E7%85%A7%E8%B4%B4%E5%9B%BE/"},{"name":"图形学","slug":"图形学","permalink":"https://cuihongzhi1991.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"UE4","slug":"UE4","permalink":"https://cuihongzhi1991.github.io/tags/UE4/"},{"name":"材质","slug":"材质","permalink":"https://cuihongzhi1991.github.io/tags/%E6%9D%90%E8%B4%A8/"},{"name":"渲染管线","slug":"渲染管线","permalink":"https://cuihongzhi1991.github.io/tags/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"},{"name":"卡通着色","slug":"卡通着色","permalink":"https://cuihongzhi1991.github.io/tags/%E5%8D%A1%E9%80%9A%E7%9D%80%E8%89%B2/"}]}