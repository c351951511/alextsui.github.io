{"meta":{"title":"Alex Technical Art","subtitle":"","description":"","author":"Alex Tsui","url":"https://cuihongzhi1991.github.io","root":"/blog/"},"pages":[{"title":"Real-Time Rendering 4th 笔记——第一章","date":"2020-04-11T12:33:36.000Z","updated":"2020-04-16T14:36:49.284Z","comments":true,"path":"DOING/RTR4Ch01.html","permalink":"https://cuihongzhi1991.github.io/DOING/RTR4Ch01.html","excerpt":"《Real-Time Rendering 4th》出版于2018年，是实时渲染圣经的第四版。此版涵盖的内容延续以往的结构，知识点到为止，展开的并不多。所以根据书中的索引可以对某一方面进行深度学习和研究。","text":"《Real-Time Rendering 4th》出版于2018年，是实时渲染圣经的第四版。此版涵盖的内容延续以往的结构，知识点到为止，展开的并不多。所以根据书中的索引可以对某一方面进行深度学习和研究。 引言实时渲染是计算机图形学交互性最强的领域。操作者做出操作或交互后可以立即得到反馈效果呈现在画面上，并根据产生的图像结果持续交互。这样一个操作与渲染的循环须有足够的计算速度才可以避免观察者看到多张不连贯的图像。图像显示速率以帧数/秒(FPS)或者赫兹(Hz)度量。每秒1帧几乎没有交互性；每秒6帧才有点交互性；游戏的目标是30、60、72或更高的FPS，例如游戏在VR头显设备运行时通常需要90FPS来最小化延迟避免产生眩晕感。实时渲染比交互性更重要，实时渲染一般指创造三维图像。交互性和三维空间关系是实时渲染的充分条件。后来，三维图形的加速硬件（显卡）也成为了实时渲染的第三个元素。不仅是电脑，平板和手机现在也内置了图形处理器。本书会着重提供可以加速和提升画面质量的方法，并且会描述加速算法和图形API的特性及限制。本书不会对每个话题深入讨论，而是展现其核心概念和专业术语，对最鲁棒和最实际的算法进行解释，并给出更多的拓展学习资料。 内容概括 第二章——图形渲染管线将场景的数据化抽象描述转换成我们可以看到的实际画面的步骤就是实时渲染的核心。 第三章——图形处理单元现代GPU使用固定方法与可编程单元的组合来实现渲染管线的各个步骤。 第四章——变换变换是修改物体位置、朝向、比例和形状的基本工具，也是修改相机位置和FOV的基本工具。 第五章——基础着色从讨论材质和灯光的含义开始，并实现写实或风格化的材质效果。另外还会介绍一些效果相关的话题，比如通过反走样、半透和伽马矫正得到质量更佳的图像。 第六章——纹理快速读取和在表面上显示图像的能力是实时渲染的强力工具之一。这个过程被称为纹理映射，有着很广泛的应用方法。 第七章——阴影给场景添加阴影既可以提升真实感也便于理解空间关系。本章会快速展示一下常用的计算阴影的算法。 第八章——光和色彩在呈现基于物理的渲染之前，需要理解如何量化光和色彩。在物理渲染过程结束后，需要转换结果为数值来展示效果，包括屏幕和观察环境的多种属性。 第九章——基于物理的着色本章会透彻讲解对基于物理的着色。会介绍背后的物理现象、各种渲染材质的数学模型、混合材质和反走样的过滤方法。 第十章——局部照明探索更精准的光照算法。当光源具有特殊形状时是如何计算表面的着色。 第十一章——全局照明模拟灯光和场景多次交互的算法大大增加图像的真实性。会讨论直接和间接光遮蔽以及渲染漫反射和镜面反射表面的全局光照的方法，还有一些可信的统一实现方式。 第十二章——图像效果图形硬件擅长快速处理图像。会先介绍图像过滤和重映射技术，然后讨论几个流行的后期处理效果，如：镜头炫光、运动模糊和景深。 第十三章——物体的其他描述形式三角形不总是描述物体最快和最真实的方式。还有一些基于图像、点云、体素和其他采样集合的方式都有各自的优点。 第十四章——体积和半透渲染重现体积感材质的理论和实践，他们是如何与光照进行交互的。从宏观的大范围氛围效果到微观如发丝的光照散射都有模拟。 第十五章——非真实感渲染让场景看起来真实只是渲染的方法之一。还可以探讨其他类型，如卡通着色、水彩风格等，线条和文本的生成技术也会在此讨论。 第十六章——多边形技术几何数据来源广泛，有时为了快速渲染和提高渲染质量会修改数据。本章会介绍描述和压缩多边形数据技术的多个方面。 第十七章——曲线和曲面更复杂的表面描述方式提供了其他的优点，比如可以在质量和渲染速度上做取舍、更加细致的描述以及生成平滑的表面。 第十八章——管线优化当应用程序使用高效的算法运行时，可以使用各种优化技术更快的运行。找到瓶颈并且决定如何解决瓶颈是本章的主题。多重处理也会在此讨论。 第十九章——加速算法不仅能运行，还要更快速。本章涵盖了各种剔除和LOD渲染方法。 第二十章——高效的着色方式在场景中，大量的光源会导致性能的下降。在片段可见性未知的情况下对其完整的渲染是浪费的。此处会探索一些可以解决这种低效着色的办法。 第二十一章——虚拟现实和增强现实该领域有其特殊的挑战和技术来实现真实、快速并且稳定的图像。 第二十二章——相交测试方法相交测试对渲染、玩家交互和碰撞检测都十分重要。本章会介绍很多几何体相交测试的高效算法。 第二十三章——图形硬件本章会介绍颜色深度、帧缓冲和基础的架构类型。给出了一个典型的GPU实例分析。 第二十四章——未来让我们猜猜看。 符号和定义TO DO 数学符号TO DO 几何定义TO DO 着色TO DO 其他学习资源Real-Time Rendering官网"},{"title":"UE4制作《地平线》体积云","date":"2020-04-17T15:30:14.000Z","updated":"2020-04-19T14:29:10.940Z","comments":true,"path":"DOING/VC-HZD2016.html","permalink":"https://cuihongzhi1991.github.io/DOING/VC-HZD2016.html","excerpt":"","text":"概览游戏中的实时体积云往往为了降低性能而降低质量。最成功的实现仅限于低空的蓬松半透的层状云。开发者提出一种有体积感的解决方案，可以用各种类型的云填满整个天空，十分真实。不仅描绘了高空的卷云，还有所有低云族的主要类型，包括厚的卷积云。另外，开发者的几中体积光效果的模拟方法还没有在这个体积云方案中呈现。最后，这个解决方案在内存和GPU开销方面表现得足够好，可以在3A的主机游戏中使用。 简介3A主机游戏云渲染的标准方案包括某些素材，比如2D公告板、带穹顶图的天空球或者体积素材库在渲染时进行实例化。像开放世界这样天空需要不断变化并且玩家视距非常远的游戏中，数据储存、多个相机角度、TOD和不同光照条件下的数据读取使得高细节资源的优势黯然失色。另外，云系统演化过程的模拟仅限于作假的方式，比如旋转天空球或者用2D噪波扭曲云的贴图。有许多不依赖资产的程序化云系统的技术。ShaderToy.com上有几个很好的免费案例，比如Quilez的“Clouds”。索尼的Evolution Studios在游戏《驾驶俱乐部》中使用TrueSky的插件呈现氛围感很强的天气效果。然而这种方式也有几个限制： 它们只描述了低高度的层云，不是蓬松汹涌的层积云或积云。 现有的方法没有针对特定的云实现真实的光照效果。 正常情况下，实时体积云性能开销很高，内存占用多，不值得为了质量好而牺牲这么多。对于游戏《地平线：黎明时分》，开发者研发了新的解决方案来解决上述的问题。他们为体积云的建模、光照和渲染提出了新的算法，在内存预算20MB和实时性能2ms的情况下实现真实和逐步演变的效果。 云的建模。。。。。。。。。。。。。。。。"},{"title":"categories","date":"2020-04-11T09:45:58.000Z","updated":"2020-04-11T09:54:15.732Z","comments":false,"path":"categories/index.html","permalink":"https://cuihongzhi1991.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-04-11T09:44:03.000Z","updated":"2020-04-11T09:54:17.823Z","comments":false,"path":"tags/index.html","permalink":"https://cuihongzhi1991.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"球面高斯函数05——用球面高斯函数近似辐射率和辐射度","slug":"sg05","date":"2020-05-05T06:14:25.000Z","updated":"2020-05-05T05:18:02.483Z","comments":true,"path":"2020/05/05/sg05/","link":"","permalink":"https://cuihongzhi1991.github.io/2020/05/05/sg05/","excerpt":"这是本系列最后一篇笔记。前两篇讨论了如何在使用球面高斯光源时近似出漫反射和镜面反射。但依然没有说明为什么要使用球面高斯光源照亮场景。回顾本系列第一篇的内容，讨论的是如何将预计算的辐射率和辐射度存储在光照贴图或探针网格中。这也是最后一篇要讨论的主题。","text":"这是本系列最后一篇笔记。前两篇讨论了如何在使用球面高斯光源时近似出漫反射和镜面反射。但依然没有说明为什么要使用球面高斯光源照亮场景。回顾本系列第一篇的内容，讨论的是如何将预计算的辐射率和辐射度存储在光照贴图或探针网格中。这也是最后一篇要讨论的主题。 本系列的其他文章可以点击下方链接跳转。 Part1-光照贴图简史Part2-球面高斯函数101Part3-球面高斯光源的漫射照明Part4-球面高斯光源的镜面高光Part5-用球面高斯函数近似辐射率和辐射度 寻找最佳匹配度数学(尤其是统计学)中的一个常见过程就是获取一组数据点，尝试找出某种可以表示数据的分析曲线，这个过程被称为曲线拟合。也可以认为是一种有损压缩，因为几百个数据点可能需要上千字节的数据，但如果用曲线去近似可能只需要存储几个字节。下图是维基百科的一个示例，图像中有一堆需要去拟合的点，这些数据点来自于正弦波，但实际上可能是各种各样的形式。下方的公式分别对应红线，绿线，橙线和蓝线。 \\begin{align} y = c_0 + c_1 \\cdot x \\nonumber \\end{align}\\begin{align} y = c_0 + c_1 \\cdot x + c_2 \\cdot x^2 \\nonumber \\end{align}\\begin{align} y = c_0 + c_1 \\cdot x + c_2 \\cdot x^2 + c_3 \\cdot x^3 \\nonumber \\end{align}\\begin{align} y = c_0 + c_1 \\cdot x + c_2 \\cdot x^2 + c_3 \\cdot x^3 + c_4\\cdot x^4\\nonumber \\end{align}从上图可以看出更复杂的公式可以形成更复杂的曲线，但需要更多的系数，需要存储更多的数据，并意味着拟合过程更加困难或开销越大。用于拟合的常见技术之一是最小二乘法，将拟合曲线和原始数据差异的总和进行最小化。 另外可以发现最终的拟合曲线其实是多个基函数的线性组合，如$x,x^2,x^3$等。其实可以使用其他的基函数来代替，比如高斯函数！同多项式一样，高斯的总和可以用少数几个系数表示更复杂的函数。例如，根据一些点使用最小二乘法拟合不同数量的高斯函数,下图左显示了一个高斯拟合，图中为两个高斯拟合，图右是三个高斯拟合。 不难发现，添加更多高斯函数时，拟合的结果更接近原始数据。 球面拟合这种拟合数据的方式不仅可以作用于一维的数据集，也可以是多维度的。例如在一个由2维球面坐标系定义的球面上有一些随机方向的样本。假设这些样板代表在该方向上无限狭窄的入射光。如果对这些数据进行最小二乘法，则得到N个球面高斯，它们相加之和可以作为球面上任意方向上辐射率的近似值。只需要拟合算法可以得出每个球面高斯的轴向，振幅和锐度，或者提前固定一些球面高斯的参数值，然后仅拟合其余参数。与庞大的辐射率样本相比，一组球面高斯系数占用的存储空间是非常少的。但如果仅使用几个球面高斯函数，得到的近似值相比原始数据会丢失很多细节。但这与球谐函数等其他存储辐射率或辐射度近似值的方式没有什么区别。下图使用HDR环境贴图作为输入数据，分别用12个和24个球面高斯做最小二乘法拟合之后的结果。 要注意的是，该拟合值作用于球面高斯的振幅上，轴向和锐度是基于球面高斯的数量提前确定好的。求解单个参数允许使用线性最小二乘法，同时拟合所有参数需要使用复杂和开销大的非线性最小二乘法。求解较少的参数降低了存储成本，因为每个探针只需要存储振幅，轴向和锐度可以用全局的常量控制。当然，增加波瓣的数量会增加复杂性和清晰度，会保留原始图像更多的高频细节。 负数球谐函数多项式中使用了负系数所以会有“Ringing”效果，球面高斯也有类似问题。上图中的球面右下角有过暗的区域。最小二乘法为了减少拟合的误差，某些波瓣返回了负系数。假如是一维的情况，有一个连续性很差的点集。用最小二乘法使两个高斯波瓣去拟合，情况如下。 优化过程中，第一个波瓣的振幅为正，第二个波瓣的振幅为负。这就导致了最终会有过暗的区域。第一篇笔记中有提到过球谐函数的类似情况以及解决办法。 那么我们需要给最小二乘法加上约束保证返回正系数。好在已经有了名为非负最小二乘法(non-negative least squares, NNLS)。如果使用该方法用球面高斯拟合原始的辐射率，那么结果会自然和正确很多。下图是HDR环境贴图、12个和24个球面高斯使用NNLS拟合之后的结果。 虽然右下角的明暗趋于正常了，但代价是相比原来的方式，近似的结果更加的模糊。 辐射度比较下面使用不同方式近似辐射率，使用辐射率直接计算出兰伯特漫反射光照的辐射度并比较它们的结果。 除了Ambient Cubemap，其他的近似值都很好。但该HDR环境贴图的照明比较柔和，不容易看出问题，下面使用明暗变化比较极端的HDR环境贴图进行比较。 这次的差异就比较明显了。有大面积的明亮光源的情况，球面高斯的效果更胜一筹，尤其是NNLS版本的12个球面高斯。 因为波瓣方向和锐度都是固定值，那么只需要储存振幅的数据即可。即12个球面高斯波瓣的存储成本等于12组RGB系数(总共36个浮点数)。L2的球谐函数需要9组RGB系数(27个浮点数)。环境立方体贴图仅需要6组RGB系数，仅为球面高斯的一半，所以使用球面高斯需要更多存储空间。然而换个角度，这也是球面高斯的优点。立方体贴图只能使用6个波瓣，职业才可以保持正交性；而球面高斯可以根据质量、性能和存储成本使用任意数量的波瓣。 半球拟合因为实际烘焙光照时，样本点存在于模型表面，所以有一半的球体是位于模型背面的，计算这部分是毫无意义的。我们只需要对模型表面的半球部分做光照的预计算然后存储起来即可。而对于球面高斯来说是很好修改的，只需要求解位于围绕面法线的上半球内的波瓣即可。 采样整个场景为光照贴图每个纹素生成辐射率的近似值，最好的方式是使用光线追踪器(ray tracer)，使用诸如路径跟踪(path tracing)之类的算法来计算特定光线的入射辐射率。下图展示了一个场景的光照贴图的可视化效果，为光照贴图每个纹素生成半球辐射率探针，每个探针使用9个围绕面法线朝向的球面高斯。 镜面反射上篇文章介绍了如何从球面高斯光源计算出镜面反射项。那么在近似入射辐射率方面使用该方式。可以计算出整个场景镜面反射的近似效果。数量较少的波瓣只能应对粗糙度较高的材质，因为球面高斯对入射辐射率的近似不能捕获环境的高频细节。下图是粗糙度为0.25的GGX分布项的测试场景。 与真实的效果相比，球面高斯在某些地方的近似不错，在某些地方的近似差一些。但总体来说比L2的球谐函数结果好不少，而且存储成本相同(27个浮点数)。球谐函数使用3D查找纹理存储预计算的球谐系数，如果仔细观察垂直相机的墙面就可以看到插值导致的瑕疵。 《教团:1886》中的实现对于场景中的静态网格体，在2D光照贴图中储存5-12个轴向和锐度值固定的球面高斯波瓣。对于动态的网格体，会提前烘焙包含球形探针的3D Grid到3D纹理中，每个探针有9个球面高斯波瓣。3D Grid是由灯光艺术家在场景中手动摆放的。然后在计算每个像素的光照前，利用硬件的纹理过滤在相邻的探针间做插值。 早期的测试是用CPU烘焙的，但最终使用的是CUDA烘焙工具做GPU烘焙，将计算结果投影到球面高斯波瓣上。下图比较了计算球面高斯波瓣计算的辐射率近似值。 为了性能和存储考虑，没有使用太多的球面高斯波瓣，这样在粗糙度较低的材质表面就会丢失很多细节。所以最终的方案是基于模型表面材质粗糙度在环境贴图和光照贴图两者中做选择，并在很小的区域内将两者的镜面反射进行混合。","categories":[{"name":"图形学","slug":"图形学","permalink":"https://cuihongzhi1991.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"球面高斯","slug":"球面高斯","permalink":"https://cuihongzhi1991.github.io/tags/%E7%90%83%E9%9D%A2%E9%AB%98%E6%96%AF/"},{"name":"图形学","slug":"图形学","permalink":"https://cuihongzhi1991.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"球面高斯函数04——球面高斯光源的镜面高光","slug":"sg04","date":"2020-05-04T06:14:25.000Z","updated":"2020-05-05T00:54:29.557Z","comments":true,"path":"2020/05/04/sg04/","link":"","permalink":"https://cuihongzhi1991.github.io/2020/05/04/sg04/","excerpt":"上篇文章中，讨论了使用漫反射BRDF时如何计算球面高斯光源的分布。下面可以讨论如何计算与视角有关的更复杂的BRDF，这样就可以得到高光的分布。本文会介绍如何逼近基于微表面的镜面反射BRDF对球面高斯光源的反应情况，并且会介绍各向异性球面高斯的概念。","text":"上篇文章中，讨论了使用漫反射BRDF时如何计算球面高斯光源的分布。下面可以讨论如何计算与视角有关的更复杂的BRDF，这样就可以得到高光的分布。本文会介绍如何逼近基于微表面的镜面反射BRDF对球面高斯光源的反应情况，并且会介绍各向异性球面高斯的概念。 本系列的其他文章可以点击下方链接跳转。 Part1-光照贴图简史Part2-球面高斯函数101Part3-球面高斯光源的漫射照明Part4-球面高斯光源的镜面高光Part5-用球面高斯函数近似辐射率和辐射度 微平面镜面反射迪士尼提出的基于物理的渲染公式是当下实时渲染领域比较流行，应用最广的。其中基于微平面的镜面反射BRDF如下： \\begin{align} f(i,o)=\\frac{F(o,h)G(i,o,h)D(h)}{4(n\\cdot{i})(n\\cdot{o})} \\nonumber \\end{align}D项通常称为法线分布函数(Normal Distribution Function, NDF)，描述微面元法线分布的概率，即正确朝向的法线的浓度。可以在粗糙度上做参数化，描述微平面的凹凸程度。低粗糙度会产生锐利清晰的镜面反射和狭窄细长的镜面波瓣；高粗糙度会产生更宽的镜面波瓣。大多数的现代游戏(包括教团:1886)的D项都用的GGX(Trowbridge-Reitz)分布。下面两图都使用的GGX分布，分别使用0.5的粗糙度和0.1的粗糙度；X轴是表面法线和半角向量的夹角。 G项是几何函数(Geometry Function)，也被称为掩蔽阴影函数(Masking-Shadow Function)。描述微平面自成阴影的属性，即微面元法线与面法线一致并未被遮蔽的表面点的百分比。下图使用的是Smith-GGX函数作为G项的曲线，粗糙度为0.25，法线与视线夹角为0。 F项是菲涅尔方程(Fresnel Equation)，描述不同的表面角下表面所反射的光线所占的比率。从F0到F90，反射强度逐渐增加。使用Schilick近似表示菲涅尔项的曲线如下，F0=0.04： 球面高斯光源的镜面反射沿用迪士尼的镜面反射BRDF，为了与精确光源以及IBL探针正常交互。但会按照球面高斯光源对其拓展： \\begin{align} L_o(0,x) = \\int_{\\Omega}\\frac{F(o,h)G(i,o,h)D(h)G_l(i;\\mu,\\lambda,a)cos(\\theta_i)d\\Omega}{4cos(\\theta_i)cos(\\theta_o)} \\nonumber \\end{align}\\begin{align} L_o(0,x) = \\int_{\\Omega}\\frac{F(o,h)G(i,o,h)D(h)ae^{\\lambda(\\mu\\cdot{i}-1)}d\\Omega}{4cos(\\theta_o)} \\nonumber \\end{align}与漫反射不同，现在积分中有多个项与视角有关。那么需要做一些激进的优化得到期望的结果。 D项D项是镜面反射BRDF中最重要的项。该分布决定了镜面高光整体的形状和强度，如果回看GGX曲线，其走势类似于高斯曲线，但不完全匹配。用单个球面高斯是不能实现紧凑高光和长拖尾的的特征。可以把多个高斯相加去逼近，但本文会用简单的单波瓣去近似。《All-Frequency Rendering of Dynamic, Spatially-Varying Reflectance》中提出过一种逼近Cook-Torrance D项的一个简单公式： \\begin{align} D(h) = e^{-(arccos(h\\cdot n)/m)^{2}} \\approx G(h;n,\\frac{2}{m^2},l) \\nonumber \\end{align}但该高斯模型的峰值并不会随着粗糙度变化而变化，好在有简单的分析公式可以计算球面高斯的积分，因此可以将整个积分的幅度值设置为1，这样一个归一化的D项就是： \\begin{align} D_{SG}(h) = G(h;n,\\frac{2}{m^2},\\frac{1}{\\pi m^2}) \\nonumber \\end{align}12345678910SG DistributionTermSG(in float3 direction, in float roughness)&#123; SG distribution; distribution.Axis = direction; float m2 = roughness * roughness; distribution.Sharpness = 2 / m2; distribution.Amplitude = 1.0f / (Pi * m2); return distribution;&#125; 下方的图标显示了当前的近似方式与GGX的差距，上图粗糙度为0.25，下图粗糙度为0.5： 域之间的扭曲现在有了球面高斯格式的法线分布函数，但却无法使用。因为我们是在半角向量中定义的分布函数，球面高斯的轴是指向面法线方向的，而且我们使用半角向量作为采样方向。如果要使用球面高斯积运算来获取球面高斯光源下的分布，必须保证分布波瓣和光源在同一个域的。换言之，分布的中心是随着观察角度变化的，因为半角向量会随着观察方向改变。 为了确保分布波瓣在正确的域中，需要对其扭曲来对齐观察方向的BRDF切片。对于微平面的镜面反射BRDF来说，波瓣是围绕视线反射方向大致居中的。下方图表就是GGX的波瓣，蓝线为观察方向，绿线是面法线方向，粉线是视线反射方向。上图视角为0度，下图视角为45度。 《All-Frequency Rendering of Dynamic, Spatially-Varying Reflectance》中提供了一个简单的扭曲算子，可以是分布波瓣围绕视线反射方向旋转，并且根据原始波瓣中心的差异差异调整锐度。 \\begin{align} \\mu_w = 2(o\\cdot \\mu_d)\\mu_d - o \\nonumber \\end{align}\\begin{align} \\lambda_w = \\frac{\\lambda_d}{4|\\mu_d\\cdot o|} \\nonumber \\end{align}\\begin{align} a_w = a_d \\nonumber \\end{align}1234567891011SG WarpDistributionSG(in SG ndf, in float3 view)&#123; SG warp; warp.Axis = reflect(-view, ndf.Axis); warp.Amplitude = ndf.Amplitude; warp.Sharpness = ndf.Sharpness; warp.Sharpness /= (4.0f * max(dot(ndf.Axis, view), 0.0001f)); return warp;&#125; 现在对比一下扭曲后的球面高斯分布项与GGX分布的差异，红色是GGX分布，绿色是球面高斯分布： 形状稍有偏离，但扭曲后的波瓣出现在了正确的位置上。 剩余项的近似剩余的G项和F项和高斯分布相差甚远，所以不能用球面高斯去近似。《All-Frequency Rendering of Dynamic, Spatially-Varying Reflectance》中针对此问题做了一些假设来回避此问题，即这些项的值在整个BRDF波瓣中保持不变，这样就可以把它们从积分中提出来，并仅针对BRDF波瓣的轴向进行评估。这使得BRDF在掠射角仍然有效果。但是随着粗糙度增加，G项和F项会离波瓣中心越远，BRDF波瓣会变宽，误差会变得明显。 \\begin{align} f_{sg}(i,o) = \\frac{F(o,h_w)G(\\mu_w,o,h_w)\\frac{1}{\\pi m^2}e^{\\lambda_w(\\mu_w \\cdot i -1)}}{4(n\\cdot \\mu_w)(n \\cdot o)} \\nonumber \\end{align}\\begin{align} h_w = \\frac{o+\\mu_w}{||o+\\mu_w||} \\nonumber \\end{align}最后是半球积分中与BRDF相乘的余弦项。《All-Frequency Rendering of Dynamic, Spatially-Varying Reflectance》中建议使用球面高斯乘积来得到一个球面高斯，该球面高斯表示球面高斯分布项与钳制余弦波的近似球面高斯相乘的结果。为了降低开销，采用G项与F项的方式，只会在BRDF波瓣的轴的方向评估余弦项。代码如下：123456789101112131415161718192021222324252627282930313233343536373839float GGX_V1(in float m2, in float nDotX)&#123; return 1.0f / (nDotX + sqrt(m2 + (1 - m2) * nDotX * nDotX));&#125; float3 SpecularTermSGWarp(in SG light, in float3 normal, in float roughness, in float3 view, in float3 specAlbedo)&#123; // Create an SG that approximates the NDF. SG ndf = DistributionTermSG(normal, roughness); // Warp the distribution so that our lobe is in the same // domain as the lighting lobe SG warpedNDF = WarpDistributionSG(ndf, view); // Convolve the NDF with the SG light float3 output = SGInnerProduct(warpedNDF, light); // Parameters needed for the visibility float3 warpDir = warpedNDF.Axis; float m2 = roughness * roughness; float nDotL = saturate(dot(normal, warpDir)); float nDotV = saturate(dot(normal, view)); float3 h = normalize(warpedNDF.Axis + view); // Visibility term evaluated at the center of // our warped BRDF lobe output *= GGX_V1(m2, nDotL) * GGX_V1(m2, nDotV); // Fresnel evaluated at the center of our warped BRDF lobe float powTerm = pow((1.0f - saturate(dot(warpDir, h))), 5); output *= specAlbedo + (1.0f - specAlbedo) * powTerm; // Cosine term evaluated at the center of the BRDF lobe output *= nDotL; return max(output, 0.0f);&#125; 下图是使用球面高斯光源照亮的场景，并使用上文中所有的镜面反射近似方式后的结果，场景的粗糙度为0.128。 各向异性上图中地板的高光又宽又圆，正常的掠射角观察的高光应该会延伸到较远的地方。所以需要重新检查一下D项。下方的3D示意图分别是观察角度较垂直和较倾斜时GGX分布项情况。不难发现角度趋近垂直时，分布情况类似球面高斯一样镜像对称。而趋近于掠射角时就像右图一样，波瓣开始伸展并且不再镜像对称。伸展的波瓣会呈现拉伸的高光。而我们目前的球面高斯分布项则不无法表示这种非对称性。 好在2013年，一篇名为《Anisotropic Spherical Gaussians》的论文解释了如何扩展球面高斯函数来支持各向异性的波瓣宽度或锐度。定义如下： \\begin{align} G(v;[\\mu_x, \\mu_y, \\mu_z], [\\lambda_x, \\lambda_y],a) = a\\cdot S(v,\\mu_z)e^{-\\lambda_x(v\\cdot \\mu_x)-\\lambda_y(v\\cdot \\mu_y)} \\nonumber \\end{align}球面高斯有一个轴，而各向异性球面高斯由$\\mu_x, \\mu_y, \\mu_z$组成了完整的正交基向量。并且各向异性球面高斯有两个锐度参数$\\lambda_x, \\lambda_y$，它们分别控制相对于$\\mu_x$和$\\mu_y$的锐度。例如设置$\\lambda_x$为16，$\\lambda_y$为64，那么拉伸的高斯波瓣就会在$\\lambda_y$方向上更狭窄，并且中心落在$\\mu_z$。下面使用这些参数将各向异性球面高斯显示在球面上： HLSL实现如下：12345678910111213141516171819struct ASG&#123; float3 Amplitude; float3 BasisZ; float3 BasisX; float3 BasisY; float SharpnessX; float SharpnessY;&#125;; float3 EvaluateASG(in ASG asg, in float3 dir)&#123; float sTerm = saturate(dot(asg.BasisZ, dir)); float lambdaTerm = asg.SharpnessX * dot(dir, asg.BasisX) * dot(dir, asg.BasisX); float muTerm = asg.SharpnessY * dot(dir, asg.BasisY) * dot(dir, asg.BasisY); return asg.Amplitude * sTerm* exp(-lambdaTerm - muTerm);&#125; 这篇各向异性球面高斯的论文还提供了两个公式，可用于提高球面高斯光源的镜面反射质量。第一个是新的扭曲算子，可以用NDF作为各向同性球面高斯，然后沿着视线方向拉伸产生比实际BRDF更好的各向异性球面高斯。另一个有用的公式是将各向异性球面高斯与各向同性球面高斯做卷积。可以用来将各向异性扭曲的NDF波瓣与球面高斯光源波瓣做卷积。下图左是球面扭曲，图中是各向异性扭曲，图右是实际的GGX分布。 各向异性的分布看起来更接近实际的GGX NDF分布，因为有了之前缺少的垂直拉伸。下面是HLSL中的实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879float3 ConvolveASG_SG(in ASG asg, in SG sg) &#123; // The ASG paper specifes an isotropic SG as // exp(2 * nu * (dot(v, axis) - 1)), // so we must divide our SG sharpness by 2 in order // to get the nup parameter expected by the ASG formula float nu = sg.Sharpness * 0.5f; ASG convolveASG; convolveASG.BasisX = asg.BasisX; convolveASG.BasisY = asg.BasisY; convolveASG.BasisZ = asg.BasisZ; convolveASG.SharpnessX = (nu * asg.SharpnessX) / (nu + asg.SharpnessX); convolveASG.SharpnessY = (nu * asg.SharpnessY) / (nu + asg.SharpnessY); convolveASG.Amplitude = Pi / sqrt((nu + asg.SharpnessX) * (nu + asg.SharpnessY)); float3 asgResult = EvaluateASG(convolveASG, sg.Axis); return asgResult * sg.Amplitude * asg.Amplitude;&#125; ASG WarpDistributionASG(in SG ndf, in float3 view)&#123; ASG warp; // Generate any orthonormal basis with Z pointing in the // direction of the reflected view vector warp.BasisZ = reflect(-view, ndf.Axis); warp.BasisX = normalize(cross(ndf.Axis, warp.BasisZ)); warp.BasisY = normalize(cross(warp.BasisZ, warp.BasisX)); float dotDirO = max(dot(view, ndf.Axis), 0.0001f); // Second derivative of the sharpness with respect to how // far we are from basis Axis direction warp.SharpnessX = ndf.Sharpness / (8.0f * dotDirO * dotDirO); warp.SharpnessY = ndf.Sharpness / 8.0f; warp.Amplitude = ndf.Amplitude; return warp;&#125; float3 SpecularTermASGWarp(in SG light, in float3 normal, in float roughness, in float3 view, in float3 specAlbedo)&#123; // Create an SG that approximates the NDF SG ndf = DistributionTermSG(normal, roughness); // Apply a warpring operation that will bring the SG from // the half-angle domain the the the lighting domain. ASG warpedNDF = WarpDistributionASG(ndf, view); // Convolve the NDF with the light float3 output = ConvolveASG_SG(warpedNDF, light); // Parameters needed for evaluating the visibility term float3 warpDir = warpedNDF.BasisZ; float m2 = roughness * roughness; float nDotL = saturate(dot(normal, warpDir)); float nDotV = saturate(dot(normal, view)); float3 h = normalize(warpDir + view); // Visibility term output *= GGX_V1(m2, nDotL) * GGX_V1(m2, nDotV); // Fresnel float powTerm = pow((1.0f - saturate(dot(warpDir, h))), 5); output *= specAlbedo + (1.0f - specAlbedo) * powTerm; // Cosine term output *= nDotL; return max(output, 0.0f);&#125; 使用各向异性扭曲后的高光效果看起来好了很多。","categories":[{"name":"图形学","slug":"图形学","permalink":"https://cuihongzhi1991.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"球面高斯","slug":"球面高斯","permalink":"https://cuihongzhi1991.github.io/tags/%E7%90%83%E9%9D%A2%E9%AB%98%E6%96%AF/"},{"name":"图形学","slug":"图形学","permalink":"https://cuihongzhi1991.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"球面高斯函数03——球面高斯光源的漫射照明","slug":"sg03","date":"2020-05-03T06:14:25.000Z","updated":"2020-05-05T00:54:35.843Z","comments":true,"path":"2020/05/03/sg03/","link":"","permalink":"https://cuihongzhi1991.github.io/2020/05/03/sg03/","excerpt":"本篇是球面高斯函数与预计算光照系列的第三部分，上篇文章提到了球面高斯函数的一些属性，本文会讨论如何在渲染场景中使用这些属性并发挥它们的优势。","text":"本篇是球面高斯函数与预计算光照系列的第三部分，上篇文章提到了球面高斯函数的一些属性，本文会讨论如何在渲染场景中使用这些属性并发挥它们的优势。 本系列的其他文章可以点击下方链接跳转。 Part1-光照贴图简史Part2-球面高斯函数101Part3-球面高斯光源的漫射照明Part4-球面高斯光源的镜面高光Part5-用球面高斯函数近似辐射率和辐射度 天降高斯假设表面的一个点x被光源L照亮，该光源由名为$G_L$的球面高斯函数表示。那么使用兰伯特漫反射BRDF计算出射光辐射率就是下方的公式： \\begin{align} L_o(o,x) = \\int_{\\Omega}{}f(i,o,x)\\cdot L_i(i,x)\\cdot\\cos(\\theta_i)\\cdot{d}\\Omega \\nonumber \\end{align}对于精确光源来讲，本质上就是按比例缩放的三角函数，计算起来像$N\\cdot{L}$一样简单。但如果使用区域光就会遇到麻烦，因为该积分没有闭式解。假设有一个奇特的高斯光源，它的角衰减可以由球面高斯函数精确地表示。如果在渲染公式中将高斯光源作为$L_i$，那么就是一个球面高斯函数与被限制范围(0-1)的余弦波做点积。上篇文章中提到过两个球面高斯做积运算的过程，那么不妨尝试将余弦波拟合成一个球面高斯函数，这样渲染公式中就是将两个球面高斯函数乘积的结果做积分了。根据Jiaping Wang等人的论文《All-Frequency Rendering of Dynamic, Spatially-Varing Reflectance》中的方法，将余弦波拟合到单个球面高斯函数时，$\\lambda$=2.133，a=1.17。代码中的实现就会变成：1234567891011121314151617181920212223SG CosineLobeSG(in float3 direction)&#123; SG cosineLobe; cosineLobe.Axis = direction; cosineLobe.Sharpness = 2.133f; cosineLobe.Amplitude = 1.17f; return cosineLobe;&#125; float3 SGIrradianceInnerProduct(in SG lightingLobe, in float3 normal)&#123; SG cosineLobe = CosineLobeSG(normal); return max(SGInnerProduct(lightingLobe, cosineLobe), 0.0f);&#125; float3 SGDiffuseInnerProduct(in SG lightingLobe, in float3 normal, in float3 albedo)&#123; float3 brdf = albedo / Pi; return SGIrradianceInnerProduct(lightingLobe, normal) * brdf;&#125; 误差分析毕竟是余弦波的近似值，肯定会有误差。最好的办法就是对比两者的曲线： 仅从图表上看，球面高斯显然与余弦波不太匹配。首先，波峰值超过了1，但必须确保曲线下方的面积与余弦波瓣尽量保持一致否则会导致能量损失。另外，球面高斯在球面上的任何地方的值都没有达到0，所以有很长的拖尾。这就意味着当逼近余弦波的球面高斯与精确光源进行积分时，光照会包裹整个球体，超过了N·L等于0的点。不过这种情况与球谐函数有类似之处，球谐函数也超过了$\\frac{\\pi}{2}$的位置，如下图所示： 使用球谐函数的情况下，近似值其实已经是负值了，或许比球面高斯的长拖尾更糟糕。L1球谐函数的近似值很差，L2球谐的近似值效果尚可。下图从左至右：振幅0-1的余弦波，逼近余弦波的球面高斯函数，L2球谐函数。 下面再看一下与球面高斯光源做计算得到漫反射光照的结果。蓝线代表双球面高斯做点积(球面高斯光源与逼近余弦波的球面高斯)。与之对比的是brute-froce数值积分求出的球面高斯与(振幅0-1)的余弦波的乘积。如图所示(球面高斯光源锐度=4.0)： 误差来自于对(振幅0-1)余弦波的近似球面高斯，而不是两个球面高斯点积的过程。最终辐射度的区别不是特别大，明显的区别就是背光区域，由双球面高斯点积的长拖尾导致的。下图使用锐度4.0的球面高斯光源，左为蒙特卡洛重要性采样计算的辐射度，右为与逼近余弦的球面高斯点积所得到的辐射度。 开销更低的近似方式上篇文章提到过球面高斯的另外一个优点——波瓣绕轴对称，并且也讨论过如何计算球面的球面高斯积分从而获得总能量。那么可以尝试从积分中提出一些项，仅对球面高斯的轴朝向做计算。这必然会引入一些误差，但如果提出的项比较平滑，那误差还是可以接受的。公式的变化如下： \\begin{align} L_o(o,x) = \\frac{C_{diffuse}}{\\pi}\\int_{\\Omega}{}G_L(i;\\mu,\\lambda,a)\\cos(\\theta_i){d}\\Omega \\nonumber \\end{align}\\begin{align} L_o(o,x) \\approx \\cos(\\theta_\\mu)\\frac{C_{diffuse}}{\\pi}\\int_{\\Omega}{}G_L(i;\\mu,\\lambda,a){d}\\Omega \\nonumber \\end{align}HLSL代码如下：12345678910111213float3 SGIrradiancePunctual(in SG lightingLobe, in float3 normal)&#123; float cosineTerm = saturate(dot(lightingLobe.Axis, normal)); return cosineTerm * 2.0f * Pi * (lightingLobe.Amplitude) / lightingLobe.Sharpness;&#125; float3 SGDiffusePunctual(in SG lightingLobe, in float3 normal, in float3 albedo)&#123; float3 brdf = albedo / Pi; return SGIrradiancePunctual(lightingLobe, normal) * brdf;&#125; 如果将这种近似方式以曲线形式和之前的作比较，会看出较大的差别。 可以发现绿线代表的是开销较低的近似方式，而曲线的走势是限制范围的余弦波的缩放版本。但是这种近似方式开销非常低，已经将球面高斯函数转成了点光源。 更精确的近似Stephen Hill提出了一种与球面高斯和余弦波积分匹配度非常高的近似方式。他的实现是针对归一化的球面高斯的，但是我们可以计算积分并缩放得到我们需要的结果。1234567891011121314151617181920212223242526272829float3 SGIrradianceFitted(in SG lightingLobe, in float3 normal)&#123; const float muDotN = dot(lightingLobe.Axis, normal); const float lambda = lightingLobe.Sharpness; const float c0 = 0.36f; const float c1 = 1.0f / (4.0f * c0); float eml = exp(-lambda); float em2l = eml * eml; float rl = rcp(lambda); float scale = 1.0f + 2.0f * em2l - rl; float bias = (eml - em2l) * rl - em2l; float x = sqrt(1.0f - scale); float x0 = c0 * muDotN; float x1 = c1 * x; float n = x0 + x1; float y = saturate(muDotN); if(abs(x0) &lt;= x1) y = n * n / x; float result = scale * y + bias; return result * ApproximateSGIntegral(lightingLobe);&#125; 其结果非常接近实际情况，并且可能开销比两个球面高斯点积更低。 在球体上对比结果——左侧是两个球面高斯点积，中间是蒙特卡洛重要性采样所得结果，右侧是Stephen Hill的近似方式。","categories":[{"name":"图形学","slug":"图形学","permalink":"https://cuihongzhi1991.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"球面高斯","slug":"球面高斯","permalink":"https://cuihongzhi1991.github.io/tags/%E7%90%83%E9%9D%A2%E9%AB%98%E6%96%AF/"},{"name":"图形学","slug":"图形学","permalink":"https://cuihongzhi1991.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"球面高斯函数02——球面高斯函数101","slug":"sg02","date":"2020-05-02T06:14:25.000Z","updated":"2020-05-05T00:54:39.380Z","comments":true,"path":"2020/05/02/sg02/","link":"","permalink":"https://cuihongzhi1991.github.io/2020/05/02/sg02/","excerpt":"本篇是球面高斯函数与预计算光照系列的第二部分，会介绍球面高斯的基础知识——球形径向基函数(spherical radial basis function, SRBF)。本文会介绍一些核心概念，后续的几篇文章会使用这些概念来计算光照贴图或探针中存储的入射光辐射率近似值。","text":"本篇是球面高斯函数与预计算光照系列的第二部分，会介绍球面高斯的基础知识——球形径向基函数(spherical radial basis function, SRBF)。本文会介绍一些核心概念，后续的几篇文章会使用这些概念来计算光照贴图或探针中存储的入射光辐射率近似值。 本系列的其他文章可以点击下方链接跳转。 Part1-光照贴图简史Part2-球面高斯函数101Part3-球面高斯光源的漫射照明Part4-球面高斯光源的镜面高光Part5-用球面高斯函数近似辐射率和辐射度 何为球面高斯函数？球面高斯函数，本质上是定义在球体表面的高斯分布函数。1D的高斯函数就是以e为底的指数函数，下图是以x=0为中心，高度为3的1D高斯函数。 在做图像模糊处理时，也曾听说或使用过高斯模糊，其本质就是使用2D的高斯函数作为滤波器。下图是高斯滤波器应用在2D图像上的白点时的效果。 分布在球面上的高斯函数也是同样的原理，只是维度有了提升，下面是球面高斯示意图。 1D的高斯函数是以下的形式： \\begin{align} ae^{\\frac{-(x-b)^{2}}{2c^{2}}} \\nonumber \\end{align}(x-b)项使1D高斯函数在笛卡尔坐标系中可以求出给定点到高斯中心的距离。而3D的球面高斯函数参数与1D和2D的不同，需要改变(x-b)项，让高斯函数根据两个单位方向向量夹角进行计算使其作用在球面上。用点积的方式就可以实现： \\begin{align} G(v;\\mu,\\lambda,a) = ae^{\\lambda(\\mu\\cdot{v}-1)}\\nonumber \\end{align}和普通高斯函数一样，有一些函数可以控制波瓣的形状和位置。参数$\\mu$是波瓣的轴向或方向，控制波瓣在球面的位置并且指向波瓣的中心；参数$\\lambda$是波瓣的锐度(sharpness)，增加该值时，波瓣会变得更纤细，也就意味着越是远离波瓣轴衰减的越快；参数a是波瓣的振幅或者强度，是波瓣波峰顶部的高度值，可以是标量值，在图形学中也可以是向量，来控制RGB不同颜色通道的变化。在HLSL代码中，只需要球面上一点的标准化方向向量就可以求出该点的球面高斯值。123456789101112struct SG&#123; float3 Amplitude; float3 Axis; float Sharpness;&#125;float3 EvaluateSG(in SG sg, in float3 dir)&#123; float cosAngle = dot(dir, sg.Axis); return sg.Amplitude * exp(sg.Sharpness * (cosAngle - 1.0f));&#125; 为何使用球面高斯函数？球面高斯函数非常直观易于理解，而且很多论文已经探索了球面高斯的使用价值，并对漫反射和镜面反射材质使用球面高斯函数实现了预计算的辐射率传递(pre-computed radiance transfer, PRT)。尤其是《All-Frequency Rendering of Dynamic, Spatially-Varing Reflectance》一文成为RAD工作室使用球面高斯函数的主要参考和灵感。 积运算对两个高斯函数做积运算可以得到另外一个高斯函数，球面高斯函数也是如此。球面上每个点对两个球面高斯函数进行积运算都会产生另外一个球面高斯函数。实质上就是向量的积运算： \\begin{align} G_1(v)G_2(v) = G(v;\\frac{\\mu_m}{||\\mu_m||},a_1a_2e^{\\lambda_m(||\\mu_m||-1)}) \\nonumber \\end{align}\\begin{align} \\lambda_m = \\lambda_1+\\lambda_2 \\nonumber \\end{align}\\begin{align} \\mu_m = \\frac{\\lambda_1\\mu_1+\\lambda_2\\mu_2}{\\lambda_1+\\lambda_2} \\nonumber \\end{align}HLSL代码如下：123456789101112131415SG SGProduct(in SG x, in SG y)&#123; float3 um = (x.Sharpness * x.Axis + y.Sharpness * y.Axis) / (x.Sharpness + y.Sharpness); float umLength = length(um); float lm = x.Sharpness + y.Sharpness; SG res; res.Axis = um * (1.0f / umLength); res.Sharpness = lm * umLength; res.Amplitude = x.Amplitude * y.Amplitude * exp(lm * (umLength - 1.0f)); return res;&#125; 积分高斯函数还有一个很好的属性——积分具有一个闭式解，也作误差函数。当然球面高斯也是如此，可以对整个球面做球面高斯积分： \\begin{align} \\int_{\\Omega}G(v)dv = 2\\pi\\frac{a}{\\lambda}(1-e^{-2\\lambda}) \\nonumber \\end{align}计算积分可以得到球面高斯的总“能量”，对光照的计算很有用。对球面高斯的归一化处理也十分有用(生成一个积分为1的球面高斯)。归一化的球面高斯可以用来表示概率分布，比如法线分布函数(Normal Distribution Function, NDF)。实际上，归一化的球面高斯函数等效于3D中的冯·米塞斯-费舍尔分布(von Mises-Fisher distribution)。 如果移除指数项的，计算球面高斯积分开销会很低。随着球面高斯的锐度增加，$(1-e^{-2\\lambda})$项的值会很快逼近1，所以只要锐度足够高，就可以在很小的误差范围内将该项移除掉。下图是锐度(X轴)增加时$(1-e^{-2\\lambda})$项(Y轴)的数值变化： 在HLSL实现球面高斯积分的准确版本和近似版本：12345678910float3 SGIntegral(in SG sg)&#123; float expTerm = 1.0f - exp(-2.0f * sg.Sharpness); return 2 * Pi * (sg.Amplitude / sg.Sharpness) * expTerm;&#125; float3 ApproximateSGIntegral(in SG sg)&#123; return 2 * Pi * (sg.Amplitude / sg.Sharpness);&#125; 点积如果要使用球面高斯积分公式计算两个球面高斯乘积的积分，就是计算两者的点积，通常定义如下： \\begin{align} \\int_{\\Omega}G_1(v)G_2(v)dv = \\frac{4\\pi{a_0}{a_1}}{e^{\\lambda{m}}}\\frac{sinh(||\\mu_m||)}{||\\mu_m||} \\nonumber \\end{align}为了避免数值上的误差可以用下面的形式： \\begin{align} \\int_{\\Omega}G_1(v)G_2(v)dv = 2\\pi{a_0}{a_1}\\frac{e^{||\\mu_m||-\\lambda_m}-e^{-||\\mu_m||-\\lambda_m}}{||\\mu_m||} \\nonumber \\end{align}HLSL中的实现如下：123456789float3 SGInnerProduct(in SG x, in SG y)&#123; float umLength = length(x.Sharpness * x.Axis + y.Sharpness * y.Axis); float3 expo = exp(umLength - x.Sharpness - y.Sharpness) * x.Amplitude * y.Amplitude; float other = 1.0f - exp(-2.0f * umLength); return (2.0f * Pi * expo * other) / umLength;&#125; 阈值球面高斯函数支持”紧凑$\\epsilon$”，也就是阈值。可以定一个角度，以球面高斯轴的$\\theta$弧度内的点的值都大于$\\epsilon$。如果将其翻转，就可以计算出锐度$\\lambda$，给定弧度$\\theta$和$\\epsilon$，反求锐度的公式如下： \\begin{align} ae^{\\lambda(cos\\theta-1)} = \\epsilon \\nonumber \\end{align}\\begin{align} \\lambda = \\frac{ln(\\epsilon)-ln(a)}{cos\\theta-1} \\nonumber \\end{align}HLSL实现如下：1234float SGSharpnessFromThreshold(in float amplitude, in float epsilon, in float cosTheta)&#123; return (log(epsilon) - log(amplitude)) / (cosTheta - 1.0f);&#125; 旋转最后一个要讨论的是旋转操作。旋转球面高斯函数很简单：只需要把旋转变换应用到球面高斯的轴向量上。旋转变换可以用矩阵、四元数或者其他方式实现。L1以上的球面高斯需要更复杂的变换。","categories":[{"name":"图形学","slug":"图形学","permalink":"https://cuihongzhi1991.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"球面高斯","slug":"球面高斯","permalink":"https://cuihongzhi1991.github.io/tags/%E7%90%83%E9%9D%A2%E9%AB%98%E6%96%AF/"},{"name":"图形学","slug":"图形学","permalink":"https://cuihongzhi1991.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"球面高斯函数01——光照贴图简史","slug":"sg01","date":"2020-05-01T06:14:25.000Z","updated":"2020-05-05T00:54:43.478Z","comments":true,"path":"2020/05/01/sg01/","link":"","permalink":"https://cuihongzhi1991.github.io/2020/05/01/sg01/","excerpt":"球面高斯函数(Spherical Gaussian, SG)是比较冷门的话题，但Ready At Dawn工作室却对其情有独钟，并使用在自研的游戏引擎中。其效果也经《教团：1886》得到验证。本系列是由Ready At Dawn工作室的首席图形和引擎工程师Matt Pettineo编写在自己的博客。我将该系列的学习笔记记录于此，与大家分享。","text":"球面高斯函数(Spherical Gaussian, SG)是比较冷门的话题，但Ready At Dawn工作室却对其情有独钟，并使用在自研的游戏引擎中。其效果也经《教团：1886》得到验证。本系列是由Ready At Dawn工作室的首席图形和引擎工程师Matt Pettineo编写在自己的博客。我将该系列的学习笔记记录于此，与大家分享。 原作者把球面高斯函数及其应用分为6篇介绍： Part1-光照贴图简史Part2-球面高斯函数101Part3-球面高斯光源的漫射照明Part4-球面高斯光源的镜面高光Part5-用球面高斯函数近似辐射率和辐射度Part6-Baking Lab的使用 最后一部分是他制作的开源的光照贴图烘焙Demo的使用方法，暂且不纳入笔记范围。笔记将记录前五篇的主要内容。作为该系列的第一篇，会简单介绍一下研究球面高斯函数(Spherical Gaussians, SG)时需要的背景资料。重点讨论预烘焙的光照贴图或探针存储了什么信息，以及如何使用这些数据来计算漫反射或镜面反射。 开始前，可以看一下文中用到的术语符号： $L_o$ -指向观察方向的出射光辐射率(radiance)$L_i$ -表面入射点的入射光辐射率o -观察方向(着色器光照计算中一般用V表示)i -光线入射方向(着色器光照计算中一般用L表示)n -表面法向量x -表面上某点的3D坐标$\\int_{\\Omega}$ -半球积分$\\theta_i$ - 表面法线与入射光的夹角角度$\\theta_o$ - 表面法线与出射光的夹角角度$f\\left(\\right)$ -BRDF 早期的方式自从有了彩色的3D游戏，就有了预先计算光照贴图的方法，一直延续到现在(2020年)。原理比较简单：为每个纹素预先计算光照数值，然后在游戏运行时对光照数值进行采样来计算表面的最终效果。虽然原理简单，但细节就比较讲究了。比如将“光照”存储在纹理中到底意味着什么？或者计算的到底是什么值？在最早期，从光照贴图中获取的数值只是简单的与材质的漫反射颜色相乘，然后直接输出颜色到屏幕上。一般我们用以下的渲染公式计算从一个入射点计算出射辐射率： \\begin{align} L_o(o,x) = \\int_{\\Omega}{}f(i,o,x)\\cdot L_i(i,x)\\cdot\\cos(\\theta_i)\\cdot{d}\\Omega \\nonumber \\end{align}暂且不考虑伽马矫正和sRGB转换等等，根据上面的描述，如果用普通的漫反射BRDF项(即$\\frac{C_{diffuse}}{\\pi}$)代替BRDF项，那么就会变成： \\begin{align} L_o(o,x) = \\int_{\\Omega}{} \\frac{C_{diffuse}}{\\pi}\\cdot L_i(i,x)\\cdot\\cos(\\theta_i)\\cdot{d}\\Omega \\nonumber \\end{align}\\begin{align} = \\frac{C_{diffuse}}{\\pi}\\int_{\\Omega}{}L_i(i,x)\\cdot\\cos(\\theta_i)\\cdot{d}\\Omega \\nonumber \\end{align}可以看到将右侧的常量项$\\frac{C_{diffuse}}{\\pi}$提到积分外，这样右侧复杂的积分运算就是预计算(pre-computed)的纹素了，因为光照贴图每个纹素存储的都是单一的固定颜色值，所以可以不用考虑观察方向，在运行时用常量项与每个纹素值相乘就是最终的颜色了。右侧的积分计算的是入射光辐射度，因此光照贴图中存储的就是入射光辐射度。实际上大多数的游戏并没有在运行时应用$\\frac{1}{\\pi}$,因为这是个常数项，为了降低开销可以也将这个常数项预计算在光照贴图中，这样只剩$C_{diffuse}$是在运行时参与计算的。这种情形下，实际存储的就是反射率。换言之，可以认为存储的值是当$C_{diffuse}=1.0$时漫反射的反射率，即具有漫反射BRDF的表面最大出射光辐射率。 法线贴图光照贴图的核心概念之一就是利用空间域中以不同密度存储的数据来重建表面的最终效果。简言之，使用一个纹素密度存储光照贴图，并与不同密度(一般更高)的反射率贴图(albedo map)结合。这样无需计算每个纹素的辐射度积分就可以保留高频细节。但如何让辐射度根据其他纹理贴图(不仅仅是反射率贴图)变化呢？为了满足这种需求，在2000年初法线贴图开始被广泛使用，但仅限于与精确光源(punctual light source)计算时使用。并且法线贴图对光照贴图不起作用，因为光照贴图只存储了辐射度的比例值(标量)，那么相比于直接光照区域，仅有环境光照(ambient lighting)的区域就非常的平整。如下图： 为了让光照贴图与法线贴图正确计算，光照贴图每个纹素不再存储单个标量值，而是辐射度的分布信息。法线贴图包含一定范围的方向分布信息，这些方向一般限制在表面上一个点的法线周围半球内。所以光照贴图存储的辐射度分布信息也是定义在同一个半球内的。V社(Valve)使用自研的Source引擎在《半条命2》中最早使用了这种分布，被称为“辐射度法线贴图”(Radiosity Normal Mapping)。 V社修改了光照贴图烘焙器算法，计算三个值而不是一个值，通过投影辐射度到上图中某一个基向量(basis vector)上得到三个值。游戏运行时，会基于法线贴图中的方向与三个基向量的夹角余弦值来混合光照贴图中的三个值从而得到辐射度值(通过开销很低的点积就可以计算)。这样就可以根据法线贴图中的方向有效地改变辐射度，进而避免了仅有环境光的区域过于平整的问题。 这个方式解决了静态物体的问题，对动态的物体和角色应用预计算的光照依然有问题。一些早期游戏(如《Quake》)用了一些技巧,例如在角色脚部位置采样光照贴图的数值，并使用该数值计算出环境光数值应用到整个模型上。而有些游戏的处理方式更粗糙，只把动态灯光和一个全局的环境光项结合使用。V社使用了更复杂的方法，将半球光照贴图基础扩展成由6个正交基向量形成的球面基础。 基向量与一个单位立方体的六个面朝向重合，V社称之为“环境立方体”。使用他们的基函数(basis functions)将辐射度投影到空间中一点周围的所有方向上(而不是面法线周围的半球上)，动态的模型可以对任意法线方向采样辐射度来计算漫反射光照。这种形式被称为“光照探针”(lighting probe)或简称“探针”(probe)。 镜面反射通过V社提出的方法，可以使用高频的法线贴图与光照贴图进行计算得到漫反射光照。为了让画面更真实，还需要支持更加复杂的BRDF，包括受观察方向影响的镜面反射BRDF。《半条命2》通过预生成(pre-generating)的立方体贴图和手动摆放的探针来处理环境的镜面反射。这在现代游戏中也是十分常见的做法(额外添加了预过滤(pre-filtering)来近似微平面BRDF)。但立方体贴图会占用大量的内存空间，因此限制了镜面反射探针(specular probe)的密度，错误的视差(parallax)或遮挡自然会产生一些问题。下图中，由于错误的视差和遮挡，当使用预过滤的环境贴图计算环境镜面反射(environment specular)时，球的边缘反射了自己导致非常亮！ 因此需要让光照贴图对镜面反射同样有影响。如果模仿漫反射BRDF，将镜面反射BRDF从积分中提出来，BRDF · Integrate(Lighting · cos($\\theta_i$))，而不是原本的Integrate(BRDF · Lighting · cos($\\theta_i$))，那么仅仅在观察方向与光照贴图基向量方向接近的时候才能看到些许镜面反射效果。下方示意图展示了改变公式后的效果。 很明显这是错误的，因为兰伯特漫反射BRDF是常量项，可以从积分中提出来，但镜面反射BRDF是与视线方向有关的，不能从积分中提出来。 球谐函数球谐函数(Spherical Harmonics, SH)是实时图形一种流行的工具，通常作为在离散的探针位置存储间接光照近似值的方式。核心就是在球面上用一系列系数(1个、4个、9个、16个、n*n个)近似出一个关于方向(方向定义在球面上)的分布函数。就像使用一个方向向量从一张立方体贴图上获取特定的值一样。使用低阶的球谐函数只能表示非常低频的信号，下图使用27个系数(RGB每通道9个系数)将HDR图投影到L2球谐函数上。 对于辐射度来讲，低频的球谐函数非常适合。相对于余弦项的入射辐射率积分有效地充当了低通滤波器，非常适合用来与球谐函数去近似辐射度。如果将探针位置或光照贴图的纹素的辐射度投影到球谐函数上，就可以进行球谐查找了(lookup)。通过与系数的点积等一些计算就可以得到球面上任意方向的辐射度。 事实证明，用球谐函数从入射辐照亮度计算辐射度很有用，因为球谐函数表示低频信号是很高效的，在频域中进行简单的乘法就可以完成卷积。在空间域中，与立方体贴图的卷积是$n^{2}$的运算，包含来自辐射率立方体贴图的很多样本。下图为L2球谐函数探针作为漫反射光源照亮的兔子模型。 因此球谐函数是用来近似辐射度的，并且可以在运行时将辐射率转化为辐射度。在探针或光照贴图中存储辐射率的近似值而不是辐射率的近似值(虽然是模糊的版本)，这样的低频信号与镜面反射BRDF的乘积进行积分可以得到镜面反射。如果用球谐函数近似辐射度，那么也需要用球谐函数近似BRDF。 然而基于微平面理论的BRDF比兰伯特漫反射BRDF复杂得多。对于漫反射光照，无论材质和观察方向如何，余弦波瓣(cosine lobe)都是相同的。但是镜面波瓣(specular lobe)根据观察方向、材质的粗糙度以及F0的菲尼尔项的不同而变化。本来使用查找表(lookup table,LUT)需要四个参数(观察方向是二维的)，但《光环3》中针对球谐函数镜面反射提出了更好的方法。当视线沿着局部Z轴(面法线)旋转时，镜面波瓣的形状不会变化，只有当视线与局部Z轴的夹角发生改变时波瓣形状才会改变(可认为视线绕局部X轴旋转)。因此可以按局部X轴的所有可能的视线方向预计算系数，这样产生的波瓣与实际的观察方向就可以对齐，如图所示： 下图展示了计算L2球谐函数光照贴图得到的间接镜面反射项。 使用球谐函数的方法有个常见的问题——“Ringing”现象。当一侧有强光时，在另一侧就会产生负的波瓣，其值就会非常低甚至是负值。对于2D光照贴图不是大问题，因为光照贴图只与面法线的半球入射辐率有关。但对于存储了整个球体的辐射率或辐射度的探针来讲就会有问题。Peter-Pike Sloan提出了一个解决方案，将窗口函数(windowing function)应用于球谐函数的系数，过滤掉Ringing现象，但窗口函数会引入额外的模糊。下图分别展示了蒙特卡洛积分离线渲染结果、投影辐射率到L2球谐函数并计算辐射度产生Ringing现象、应用窗口函数后的效果修正。","categories":[{"name":"图形学","slug":"图形学","permalink":"https://cuihongzhi1991.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"球面高斯","slug":"球面高斯","permalink":"https://cuihongzhi1991.github.io/tags/%E7%90%83%E9%9D%A2%E9%AB%98%E6%96%AF/"},{"name":"光照贴图","slug":"光照贴图","permalink":"https://cuihongzhi1991.github.io/tags/%E5%85%89%E7%85%A7%E8%B4%B4%E5%9B%BE/"},{"name":"图形学","slug":"图形学","permalink":"https://cuihongzhi1991.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"UE4使用插件创建Global Shader","slug":"ueglobalshader","date":"2020-04-28T14:19:15.000Z","updated":"2020-04-28T14:51:23.876Z","comments":true,"path":"2020/04/28/ueglobalshader/","link":"","permalink":"https://cuihongzhi1991.github.io/2020/04/28/ueglobalshader/","excerpt":"UE4的Global Shader在很久之前的版本就有了，并且底层的渲染管线也是使用Global Shader渲染Light Shaft、Volumetric Fog等等。而且由于版本的更迭，很多设置参数的方式和调用的函数都渐渐改变。虽然旧的一些特性依然使用原来的方式，但新的一些特性如4.24的大气系统都开始使用新的方式。本文记录的就是4.24版本使用较新的方式设置参数，传递参数以及调用函数的方法。","text":"UE4的Global Shader在很久之前的版本就有了，并且底层的渲染管线也是使用Global Shader渲染Light Shaft、Volumetric Fog等等。而且由于版本的更迭，很多设置参数的方式和调用的函数都渐渐改变。虽然旧的一些特性依然使用原来的方式，但新的一些特性如4.24的大气系统都开始使用新的方式。本文记录的就是4.24版本使用较新的方式设置参数，传递参数以及调用函数的方法。 创建插件使用UE4.24版本创建空插件模板，命名CustomGlobalShader。 之后会将渲染逻辑和游戏逻辑分别写在两个模块中，CustomGlobalShader.uplugin中填写需要加载的模块。 为两个模块分别创建两个文件夹，并且创建Shaders文件夹作为shader路径 ShaderDeclaration模块创建模块首先修改.Build.cs文件，添加依赖的模块，如Renderer, RendererCore, RHI和Projects。123456789101112using UnrealBuildTool;public class ShaderDeclaration : ModuleRules&#123; public ShaderDeclaration(ReadOnlyTargetRules Target) : base(Target) &#123; PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs; PrivateDependencyModuleNames.AddRange( new string[] &#123; \"Core\", \"CoreUObject\", \"Engine\", \"Renderer\", \"RenderCore\", \"RHI\", \"Projects\" &#125;); &#125;&#125; ShaderDeclaration.h因为在插件中已经有了模块接口，直接用它与Renderer交互即可。并且提供了将游戏模块与渲染hook解耦的优点，允许更安全和简单的清理。随着4.22的到来，API中可以看到Renderer被大改成更现代的使用方式，就像DX12一样。最大的区别是现在必须将渲染代码封装到一个Render Graph或者Render Pass中。两者各有优点。 Render graphs在UE4中，如果要处理较大的渲染作业并使用引擎池的渲染目标，通常会使用graph。由于引擎现在为了渲染任务专门使用任务graph。使用前从案例中学习也是更简单正确的方式。然而与UObject渲染资源（如Utextures）交互时就非常难用，所以可以使用Render pass来代替。graph通常在应对大体量作业时比较好，对于小规模的作业可以使用Render pass。 Render passesPasses与之前的图形API类似，现在使用光栅化的时候会使用Pass。现在可以创建一个渲染Pass，而不是为光栅化操作设置渲染目标。不使用光栅化的操作（如计算、拷贝和其他操作）可以像之前一样直接使用RHICommandList。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#pragma once#include \"CoreMinimal.h\"#include \"Modules/ModuleManager.h\"#include \"Runtime/Engine/Classes/Engine/TextureRenderTarget2D.h\" // UTextureRenderTarget2D#include \"RenderGraphResources.h\" // IPooledRenderTargetstruct FShaderUsageParameters&#123; UTextureRenderTarget2D* RenderTarget; FColor InputColor; FIntPoint GetRenderTargetSize() const &#123; return CachedRenderTargetSize; &#125; FShaderUsageParameters() &#123;&#125; FShaderUsageParameters(UTextureRenderTarget2D* InRenderTarget) : RenderTarget(InRenderTarget) , InputColor(FColor::White) &#123; CachedRenderTargetSize = RenderTarget ? FIntPoint(RenderTarget-&gt;SizeX, RenderTarget-&gt;SizeY) : FIntPoint::ZeroValue; &#125;private: FIntPoint CachedRenderTargetSize;&#125;;class SHADERDECLARATION_API FShaderDeclarationModule : public IModuleInterface&#123;public: static inline FShaderDeclarationModule&amp; Get() &#123; return FModuleManager::LoadModuleChecked&lt;FShaderDeclarationModule&gt;(\"ShaderDeclaration\"); &#125; static inline bool IsAvailable() &#123; return FModuleManager::Get().IsModuleLoaded(\"ShaderDeclaration\"); &#125; virtual void StartupModule() override; virtual void ShutdownModule() override;public: // 想hook renderer开始渲染时可以调用该方法。每帧都会执行着色器。 void BeginRendering(); // 结束时，调用停止绘制函数 void EndRendering(); // 需要分享新参数时就调用该方法。可以在保存locking和GPU传输时的不同间隙设置它来更新不同的属性集 void UpdateParameters(FShaderUsageParameters&amp; DrawParameters);private: TRefCountPtr&lt;IPooledRenderTarget&gt; UserRenderTarget; FShaderUsageParameters CachedShaderUsageParameters; FDelegateHandle OnPostResolvedSceneColorHanndle; FCriticalSection RenderEveryFrameLock; volatile bool bCachedParametersValid; void PostResolveSceneColor_RenderThread(FRHICommandListImmediate&amp; RHICmdList, class FSceneRenderTargets&amp; SceneContext); void Draw_RenderThread(const FShaderUsageParameters&amp; DrawParameters);&#125;; ShaderDeclaration.cpp游戏线程会调用以下的方法，开始渲染、停止渲染、更新参数等等。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include \"ShaderDeclaration.h\"#include \"SimpleColor.h\"#include \"Misc/Paths.h\" // FPath#include \"Interfaces/IPluginManager.h\" // IPluginManager#include \"RenderGraphBuilder.h\" // Debug stat macro#include \"RenderTargetPool.h\" // GRenderTargetPoolIMPLEMENT_MODULE(FShaderDeclarationModule, ShaderDeclaration)// 声明一些GPU统计数据，后续方便追踪DECLARE_GPU_STAT_NAMED(GlobalShaderPlugin_Render, TEXT(\"GlobalShaderPlugin: Root Render\"));DECLARE_GPU_STAT_NAMED(GlobalShaderPlugin_Pixel, TEXT(\"GlobalShaderPlugin: Render Pixel Shader\"));void FShaderDeclarationModule::StartupModule()&#123; OnPostResolvedSceneColorHanndle.Reset(); bCachedParametersValid = false; // 映射虚拟的着色器资源路径到插件实际的着色器路径 FString GlobalShaderDir = FPaths::Combine(IPluginManager::Get().FindPlugin(TEXT(\"CustomGlobalShader\"))-&gt;GetBaseDir(), TEXT(\"Shaders\")); AddShaderSourceDirectoryMapping(TEXT(\"/CustomShaders\"), GlobalShaderDir);&#125;void FShaderDeclarationModule::ShutdownModule()&#123; EndRendering();&#125;void FShaderDeclarationModule::BeginRendering()&#123; if (OnPostResolvedSceneColorHanndle.IsValid()) &#123; return; &#125; bCachedParametersValid = false; // 获取Renderer模块 const FName RendererModuleName(\"Renderer\"); IRendererModule* RendererModule = FModuleManager::GetModulePtr&lt;IRendererModule&gt;(RendererModuleName); if (RendererModule) &#123; OnPostResolvedSceneColorHanndle = RendererModule-&gt;GetResolvedSceneColorCallbacks().AddRaw(this, &amp;FShaderDeclarationModule::PostResolveSceneColor_RenderThread); &#125;&#125;void FShaderDeclarationModule::EndRendering()&#123; if (!OnPostResolvedSceneColorHanndle.IsValid()) &#123; return; &#125; const FName RendererModuleName(\"Renderer\"); IRendererModule* RendererModule = FModuleManager::GetModulePtr&lt;IRendererModule&gt;(RendererModuleName); if (RendererModule) &#123; RendererModule-&gt;GetResolvedSceneColorCallbacks().Remove(OnPostResolvedSceneColorHanndle); &#125; OnPostResolvedSceneColorHanndle.Reset();&#125;void FShaderDeclarationModule::UpdateParameters(FShaderUsageParameters&amp; DrawParameters)&#123; RenderEveryFrameLock.Lock(); CachedShaderUsageParameters = DrawParameters; bCachedParametersValid = true; RenderEveryFrameLock.Unlock();&#125;void FShaderDeclarationModule::PostResolveSceneColor_RenderThread(FRHICommandListImmediate&amp; RHICmdList, class FSceneRenderTargets&amp; SceneContext)&#123; if (!bCachedParametersValid) &#123; return; &#125; // 根据数据可以选择是否锁，添加此代码只是为了演示如何锁 RenderEveryFrameLock.Lock(); FShaderUsageParameters Copy = CachedShaderUsageParameters; RenderEveryFrameLock.Unlock(); Draw_RenderThread(Copy);&#125;void FShaderDeclarationModule::Draw_RenderThread(const FShaderUsageParameters&amp; DrawParameters)&#123; check(IsInRenderingThread()); if (!DrawParameters.RenderTarget) &#123; return; &#125; FRHICommandListImmediate&amp; RHICmdList = GRHICommandList.GetImmediateCommandList(); QUICK_SCOPE_CYCLE_COUNTER(STAT_GlobalShaderPlugin_Render); // 为UE4前端收集CPU分析数据 SCOPED_DRAW_EVENT(RHICmdList, GlobalShaderPlugin_Render); // 为分析GPU活动添加的元数据，可以用RenderDoc这种工具查看 if (!UserRenderTarget.IsValid()) &#123; // 创建缓存RT描述符，FPooledRenderTarget是渲染线程允许共享和纹理可视化的渲染目标。 FPooledRenderTargetDesc UserRenderTargetDesc(FPooledRenderTargetDesc::Create2DDesc(DrawParameters.GetRenderTargetSize(), PF_R32_UINT, FClearValueBinding::None, TexCreate_None, TexCreate_ShaderResource | TexCreate_UAV, false)); UserRenderTargetDesc.DebugName = TEXT(\"GlobalShaderPlugin_UserRenderTarget\"); // 如果旧元素依然有效则返回true, 分配了新元素则返回false GRenderTargetPool.FindFreeElement(RHICmdList, UserRenderTargetDesc, UserRenderTarget, TEXT(\"GlobalShaderPlugin_UserRenderTarget\")); &#125; FSimpleColor::DrawToRenderTarget_RenderThread(RHICmdList, DrawParameters, UserRenderTarget-&gt;GetRenderTargetItem().TargetableTexture);&#125; SimpleColor.h声明一个简单着色器的绘制函数12345678910#pragma once#include \"CoreMinimal.h\"#include \"ShaderDeclaration.h\"class FSimpleColor&#123;public: static void DrawToRenderTarget_RenderThread(FRHICommandListImmediate&amp; RHICmdList, const FShaderUsageParameters&amp; DrawParameters, FTextureRHIRef UserRenderTarget);&#125;; SimpleColor.cpp此处会创建两个Global Shader，分别是顶点着色器和像素着色器。并且通过IMPLEMENT_GLOBAL_SHADER()进行绑定。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include \"SimpleColor.h\"#include \"Containers/DynamicRHIResourceArray.h\" // TResourceArray#include \"Runtime/RenderCore/Public/PixelShaderUtils.h\" // FFilterVertex// 基础的静态顶点缓冲class FSimpleScreenVertexBuffer : public FVertexBuffer&#123;public: // 为渲染资源初始化RHI void InitRHI() &#123; // FFilterVertex 表示顶点数据是用来过滤纹理的， VERTEXBUFFER_ALIGNMENT 是内存分配时的对齐方式 TResourceArray&lt;FFilterVertex, VERTEXBUFFER_ALIGNMENT&gt; Vertices; Vertices.SetNumUninitialized(6); Vertices[0].Position = FVector4(-1, 1, 0, 1); Vertices[0].UV = FVector2D(0, 0); Vertices[1].Position = FVector4(1, 1, 0, 1); Vertices[1].UV = FVector2D(1, 0); Vertices[2].Position = FVector4(-1, -1, 0, 1); Vertices[2].UV = FVector2D(0, 1); Vertices[3].Position = FVector4(1, -1, 0, 1); Vertices[3].UV = FVector2D(1, 1); // 创建顶点缓冲区， 用上方创建的初始数据填充该缓冲 FRHIResourceCreateInfo CreateInfo(&amp;Vertices); VertexBufferRHI = RHICreateVertexBuffer(Vertices.GetResourceDataSize(), BUF_Static, CreateInfo); &#125;&#125;;// 声明一个顶点缓冲TGlobalResource&lt;FSimpleScreenVertexBuffer&gt; GSimpleScreenVertexBuffer;// 基础的顶点着色器class FSimpleColorVS : public FGlobalShader&#123;public: DECLARE_GLOBAL_SHADER(FSimpleColorVS); static bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters&amp; Parameters) &#123; return true; &#125; static void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters&amp; Parameters, FShaderCompilerEnvironment&amp; OutEnvironment) &#123; FGlobalShader::ModifyCompilationEnvironment(Parameters, OutEnvironment); &#125; FSimpleColorVS() &#123;&#125; FSimpleColorVS(const ShaderMetaType::CompiledShaderInitializerType&amp; Initializer) : FGlobalShader(Initializer) &#123;&#125;&#125;;// 像素着色器，参数作为cpp和HLSL的桥梁class FSimpleColorPS : public FGlobalShader&#123;public: DECLARE_GLOBAL_SHADER(FSimpleColorPS); SHADER_USE_PARAMETER_STRUCT(FSimpleColorPS, FGlobalShader); // 和游戏线程的参数一一对应 BEGIN_SHADER_PARAMETER_STRUCT(FParameters,) SHADER_PARAMETER(FVector4, InputColor) END_SHADER_PARAMETER_STRUCT() static bool ShouldCompilePermutation(const FGlobalShaderPermutationParameters&amp; Parameters) &#123; return IsFeatureLevelSupported(Parameters.Platform, ERHIFeatureLevel::SM5); &#125; static void ModifyCompilationEnvironment(const FGlobalShaderPermutationParameters&amp; Parameters, FShaderCompilerEnvironment&amp; OutEnvironment) &#123; FGlobalShader::ModifyCompilationEnvironment(Parameters, OutEnvironment); &#125;&#125;;// 告诉引擎创建着色器以及着色器的入口位置 // 着色器类型 着色器路径 着色器函数名 类型IMPLEMENT_GLOBAL_SHADER(FSimpleColorVS, \"/CustomShaders/PixelShader.usf\", \"MainVertexShader\", SF_Vertex);IMPLEMENT_GLOBAL_SHADER(FSimpleColorPS, \"/CustomShaders/PixelShader.usf\", \"MainPixelShader\", SF_Pixel);void FSimpleColor::DrawToRenderTarget_RenderThread(FRHICommandListImmediate&amp; RHICmdList, const FShaderUsageParameters&amp; DrawParameters, FTextureRHIRef UserRenderTarget)&#123; QUICK_SCOPE_CYCLE_COUNTER(STAT_CustomGlobalShaderPlugin_PixelShader); // 为UE4前端收集CPU分析数据 SCOPED_DRAW_EVENT(RHICmdList, CustomGlobalShaderPlugin_Pixel); // 为分析GPU活动添加的元数据，可以用RenderDoc这种工具查看 FRHIRenderPassInfo RenderPassInfo(DrawParameters.RenderTarget-&gt;GetRenderTargetResource()-&gt;GetRenderTargetTexture(), ERenderTargetActions::Clear_Store); RHICmdList.BeginRenderPass(RenderPassInfo, TEXT(\"CustomGlobalShaderPlugin_OutputToRenderTarget\")); auto ShaderMap = GetGlobalShaderMap(GMaxRHIFeatureLevel); TShaderMapRef&lt;FSimpleColorVS&gt; VertexShader(ShaderMap); TShaderMapRef&lt;FSimpleColorPS&gt; PixelShader(ShaderMap); // 设置图形管线状态 FGraphicsPipelineStateInitializer GraphicsPSOInit; RHICmdList.ApplyCachedRenderTargets(GraphicsPSOInit); GraphicsPSOInit.BlendState = TStaticBlendState&lt;&gt;::GetRHI(); GraphicsPSOInit.RasterizerState = TStaticRasterizerState&lt;&gt;::GetRHI(); GraphicsPSOInit.DepthStencilState = TStaticDepthStencilState&lt;false, CF_Always&gt;::GetRHI(); GraphicsPSOInit.BoundShaderState.VertexDeclarationRHI = GFilterVertexDeclaration.VertexDeclarationRHI; GraphicsPSOInit.BoundShaderState.VertexShaderRHI = GETSAFERHISHADER_VERTEX(*VertexShader); GraphicsPSOInit.BoundShaderState.PixelShaderRHI = GETSAFERHISHADER_PIXEL(*PixelShader); GraphicsPSOInit.PrimitiveType = PT_TriangleStrip; SetGraphicsPipelineState(RHICmdList, GraphicsPSOInit); // 设置像素着色器颜色，将游戏线程的参数传进来 FSimpleColorPS::FParameters PassParameters; PassParameters.InputColor = FVector4(DrawParameters.InputColor.R, DrawParameters.InputColor.G, DrawParameters.InputColor.B, DrawParameters.InputColor.A) / 255.0f; // 提交参数到RHI命令列表 SetShaderParameters(RHICmdList, *PixelShader, PixelShader-&gt;GetPixelShader(), PassParameters); // 绘制 RHICmdList.SetStreamSource(0, GSimpleScreenVertexBuffer.VertexBufferRHI, 0); RHICmdList.DrawPrimitive(0, 2, 1); // 完成渲染目标 RHICmdList.CopyToResolveTarget(DrawParameters.RenderTarget-&gt;GetRenderTargetResource()-&gt;GetRenderTargetTexture(), DrawParameters.RenderTarget-&gt;GetRenderTargetResource()-&gt;TextureRHI, FResolveParams()); RHICmdList.EndRenderPass();&#125; PixelShader.usf着色器的声明模块基本结束。需要创建与之对应的着色器文件.usf放在Shaders文件夹。1234567891011121314// VERTEX SHADERvoid MainVertexShader(float4 InPosition : ATTRIBUTE0, float2 InUV : ATTRIBUTE1, out float2 OutUV : TEXCOORD0, out float4 OutPosition : SV_POSITION)&#123; OutPosition = InPosition; OutUV = InUV;&#125;// PIXEL SHADERfloat4 InputColor;void MainPixelShader(in float2 uv : TEXCOORD0, out float4 OutColor : SV_Target0)&#123; OutColor = InputColor;&#125; 着色器应用模块创建模块首先修改.Build.cs文件，添加依赖的模块，如上面创建的ShaderDeclaration12345678910111213using UnrealBuildTool;public class ShaderUsage : ModuleRules&#123; public ShaderUsage(ReadOnlyTargetRules Target) : base(Target) &#123; PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs; PublicDependencyModuleNames.AddRange( new string[] &#123; \"Core\", \"CoreUObject\", \"Engine\", \"RHI\", \"ShaderDeclaration\" &#125;); &#125;&#125; ShaderUsage.h基本的模块功能。123456789101112131415161718#pragma once#include \"CoreMinimal.h\"#include \"Modules/ModuleManager.h\"class FShaderUsageModule : public IModuleInterface&#123;public: static inline FShaderUsageModule&amp; Get() &#123; return FModuleManager::LoadModuleChecked&lt;FShaderUsageModule&gt;(\"ShaderUsage\"); &#125; static inline bool IsAvailable() &#123; return FModuleManager::Get().IsModuleLoaded(\"ShaderUsage\"); &#125;&#125;; ShaderUsage.cpp123#include \"ShaderUsage.h\"IMPLEMENT_MODULE(FShaderUsageModule, ShaderUsage) TestActor.h创建一个测试Actor类。123456789101112131415161718192021#pragma once#include \"CoreMinimal.h\"#include \"GameFramework/Actor.h\"#include \"TestActor.generated.h\"UCLASS()class ATestActor : public AActor&#123; GENERATED_BODY()public: UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = GlobalShader) FColor InputColor; UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = GlobalShader) class UTextureRenderTarget2D* UserRenderTarget;public: virtual void BeginPlay() override; virtual void BeginDestroy() override; virtual void Tick(float DeltaTime) override;&#125;; TestActor.cpp1234567891011121314151617181920212223242526#include \"TestActor.h\"#include \"ShaderDeclaration.h\"void ATestActor::BeginPlay()&#123; Super::BeginPlay(); FShaderDeclarationModule::Get().BeginRendering();&#125;void ATestActor::BeginDestroy()&#123; FShaderDeclarationModule::Get().EndRendering(); Super::BeginDestroy();&#125;void ATestActor::Tick(float DeltaTime)&#123; Super::Tick(DeltaTime); FShaderUsageParameters DrawParameters(UserRenderTarget); &#123; DrawParameters.InputColor = InputColor; &#125; FShaderDeclarationModule::Get().UpdateParameters(DrawParameters);&#125; 目前应用模块也已经完成，编译完成后，在引擎中测试效果。 测试结果首先以TestActor为父类创建蓝图类。然后创建一个RT，和一个使用该RT的材质。蓝图类中添加一个Box，并使用该测试材质。EventTick每帧传入随机的颜色，Play一下便可以看到颜色不断变化的Box了。","categories":[{"name":"Unreal Engine","slug":"Unreal-Engine","permalink":"https://cuihongzhi1991.github.io/categories/Unreal-Engine/"}],"tags":[{"name":"UE4","slug":"UE4","permalink":"https://cuihongzhi1991.github.io/tags/UE4/"},{"name":"材质","slug":"材质","permalink":"https://cuihongzhi1991.github.io/tags/%E6%9D%90%E8%B4%A8/"},{"name":"渲染管线","slug":"渲染管线","permalink":"https://cuihongzhi1991.github.io/tags/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"}]},{"title":"UE4.22+ 添加自定义卡通着色模型","slug":"ue4addshadingmodel","date":"2020-04-25T06:14:25.000Z","updated":"2020-04-28T13:19:35.113Z","comments":true,"path":"2020/04/25/ue4addshadingmodel/","link":"","permalink":"https://cuihongzhi1991.github.io/2020/04/25/ue4addshadingmodel/","excerpt":"UE4中内置了一些着色模型(Shading Model)，基本满足了绝大部分游戏开发的需求。但一些特殊美术风格的游戏也许需要自定义着色模型，比如当下火热的二次元向游戏。本文记录了4.22+版本添加自定义着色模型的方法。","text":"UE4中内置了一些着色模型(Shading Model)，基本满足了绝大部分游戏开发的需求。但一些特殊美术风格的游戏也许需要自定义着色模型，比如当下火热的二次元向游戏。本文记录了4.22+版本添加自定义着色模型的方法。 创建自定义着色模型添加着色模型类型在EngineTypes.h中为自定义的着色模型添加一个新的UENUM。MaterialShader.cpp 添加一个枚举只是可以在材质编辑器看到而已，必须要定义这个着色模型。首先要设置编译这个着色器的环境。通过SetDefine()实现。SetDefine()函数的作用是为着色器添加一个属性的#define预处理器，编译着色器时就知道按照何种着色模型去编译。下面的代码就会让着色器编译器将MATERIAL_SHADINGMODEL_CEL_SHADING认作1.HLSLMaterialTranslator.h 开启材质引脚将会使用CustomData0和1作为Cel Bands和Outline Thickness的引脚。只需要在Material.cpp中的MP_CustomData0和MP_CustomData1之后添加开启条件。 CustomData可以保持CustomData0或1的引脚名称，也可以自定义名字。在MaterialGraph.cpp中的GetCustomDataPinName()中添加着色模型对应的引脚名称。 另外CustomData0和1的范围是0到1，所以大于1的数值n操作最好用1/n做后续数学计算。可以在AllocGBufferTargets()函数中看到UE4使用的是B8G8R8A8存储GBuffer的，CustomData的数据是储存在R或G通达的，8-bit小数最大值会被限制1.0。 借Refraction的引脚修改case MP_Refraction引脚的激活条件。 但是编译材质图标节点到着色器代码时，UE会检查冗余和不持支的内容，不支持的部分就会丢弃掉，或者被默认值代替。在HLSLMaterialTranslator.h的Translate()中，Refraction引脚只有混合模式为半透的时候才会编译，所以修改一下编译条件。 在MaterialGraph.cpp的RebuildGraph()函数中可以修改Refraction引脚名称的实现方式，用GetRefractionPinName()函数获取最终名称。 现在已经修改好所有的cpp和h文件,可以编译引擎工程。 修改着色器：BasePass和GBuffer建立着色模型ID和颜色在ShadingCommon.ush中定义新的SHADINGMODELID，并设置ID和颜色 为了让GBuffer输出CustomData，需要在BasePassCommon.ush中扩展输出条件 输出GBuffer数据的准备工作ShadingModelsMaterial.ush中的SetGBufferForShadingModel()函数会设置GBuffer的数据，添加Cel着色模型的情况。 但是Refraction引脚的数据需要用GetMaterialRefraction(FPixelMaterialInputs PixelMaterialInputs)，可以在BasePassPixelShader.ush中使用PixelMaterialInpus输入参数得到Refraction引脚的数据。 修改着色器：DeferredPass和Lighting光照调整DeferredLightPixelMain()函数在DeferredLightPixelShaders.usf中。颜色是通过GetDynamicLighting()函数实现的，该函数位于DeferredLightingCommon.ush中。首先获取阴影项，然后调用函数IntegrateBxDF()函数得到光照项。在该函数中，不同的着色模型会执行不同的BxDF()，所以可以在ShadingModels.ush的IntegratedBxDF()函数中添加CelShadingBxDF()。可以以DefaultLitBxDF()为基础修改和扩展。 阴影调整阴影还是默认的柔和，在GetDynamicLighting()中的IntegrateBxDF()前调用了GetShadowTerms()。在计算光照颜色的时候将LightColor与LightMask和Shadow.SurfaceShadow进行了相乘。所以只需要对LightMask和Shadow.SurfaceShadow进行一步处理，得到分层的锐利阴影即可。DeferredLightingCommon.ush 反射调整在ReflectionEnvironmentPixelShader.ush文件中加入判断条件，如果是卡通着色模型，就转为LAB格式调整亮度再转回RGB。 描边因为是延迟渲染，所以可以在延迟光照的步骤可以拿到深度和法线做描边。 修改代码在DeferredLightPixelShaders.usf的DeferredLightPixelMain()中添加函数CalcSceneDepth()。SceneTexturesStruct包含了GBufferA/B/C/DTexture，场景深度就在其中。法线存在GBufferA。","categories":[{"name":"Unreal Engine","slug":"Unreal-Engine","permalink":"https://cuihongzhi1991.github.io/categories/Unreal-Engine/"}],"tags":[{"name":"UE4","slug":"UE4","permalink":"https://cuihongzhi1991.github.io/tags/UE4/"},{"name":"材质","slug":"材质","permalink":"https://cuihongzhi1991.github.io/tags/%E6%9D%90%E8%B4%A8/"},{"name":"卡通着色","slug":"卡通着色","permalink":"https://cuihongzhi1991.github.io/tags/%E5%8D%A1%E9%80%9A%E7%9D%80%E8%89%B2/"},{"name":"渲染管线","slug":"渲染管线","permalink":"https://cuihongzhi1991.github.io/tags/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"}]},{"title":"UE4.22+ 添加Uniform","slug":"ue4uniform","date":"2020-04-23T05:10:39.000Z","updated":"2020-04-28T13:19:40.526Z","comments":true,"path":"2020/04/23/ue4uniform/","link":"","permalink":"https://cuihongzhi1991.github.io/2020/04/23/ue4uniform/","excerpt":"Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式，Uniform是全局的(Global)。全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。第二，无论你把Uniform值设置成什么，Uniform会一直保存它们的数据，直到它们被重置或更新。UE4的材质编辑器可以调用的红色节点中很多就是Uniform，如ObjectBounds，ActorPosition等等。本文记录了如何在UE4.22或更高版本添加自定义的Uniform，并且生成材质节点在任意材质中调用，该Uniform值也将显示在场景的Skylight组件上供用户修改。","text":"Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式，Uniform是全局的(Global)。全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。第二，无论你把Uniform值设置成什么，Uniform会一直保存它们的数据，直到它们被重置或更新。UE4的材质编辑器可以调用的红色节点中很多就是Uniform，如ObjectBounds，ActorPosition等等。本文记录了如何在UE4.22或更高版本添加自定义的Uniform，并且生成材质节点在任意材质中调用，该Uniform值也将显示在场景的Skylight组件上供用户修改。 创建CPU中的数据结构体FShaderParametersMetadata这是一个4.22的新类，4.21有一个类似的结构体FUniformBufferStruct。4.22中可以在ShaderParameterMetadata.h中找到这个类。FShaderParametersMetadata是一个储存了多个着色器参数的集合或容器。该容器可以储存不同数据类型的参数。每个参数都是一个成员，可以是矩阵、向量、数组或者纹理。（提示：FShaderParameter.h中还定义了另外一个着色器参数系统。有FShaderParameter, FShaderResourceParameter, FShaderUniformBufferParameter等等。依然可以在单独的着色器中使用，如在LightRendering.cpp中一样。）如果要定义一组着色器参数，可以用宏来声明这些元数据，这是将它们放进UniformBuffer的快捷办法。 ShaderParameterMacros.h这个头文件中包含了一些声明参数结构体的宏。比如BEGIN_GLOBAL_SHADER_PARAMETER_STRUCT()和END_GLOBAL_SHADER_PARAMETER_STRUCT()。这两个宏创建了一个类作为ParameterMetadata的壳，如：123456789// Begin Macro:class STRUCT_NAME &#123;static Metadata;CreateUniformBuffer() (when declare as GLOBAL)...Parameter Macro: Insert all members (Parameter)...// End:some ending stuff + &#125;对于全局的参数结构体，cpp中需要添加另外一个宏： IMPLEMENT_GLOBAL_SHADER_PARAMETER_STRUCT(FMyParameterStruct, “MyShaderBindingName”);这个宏将静态的元数据放入一个全局的容器，扩展后的宏类似下方：12FShaderParametersMetadata StructTypeName::Metadata(...);=&gt; FShaderParametersMetadata(..) &#123; Add-Self-To-Global-Container &#125;现在有了元数据的壳，可以开始使用SHADER_PARAMETER(Type, Name) 添加一些参数到壳中，用类型和名称创建一个成员，然后添加该成员到元数据的成员数组中。（提示：有两个版本的声明：GLOBAL和LOCAL，区别是GLOBAL会在类中创建一个UniformBuffer并且所有成员会放进这个缓冲中，另外GLOBAL会将元数据保存在全局的map和list中。而LOCAL方式不会创建内在的UniformBuffer，所以不用调用IMPLEMENT_宏。) 案例：Primitive Uniform, View Uniform可以参考一下PrimitiveUniform和ViewUniform，两个最重要的UniformShaderParameters。 PrimitiveUniformShaderParameters.h该头文件中声明了一个FPrimitiveUniformShaderParameters的结构体。之所以比较重要是因为在检索着色器代码的时候经常会看到”Primitive”或”GetPrimitiveData()“这样的变量，都是来自这个uniform结构体的。它保存了一个图元（或图元组件）的信息，包括LocalToWorld, WorldToLocal等等。 FViewUniformShaderParameters(SceneView.h)可以认为这是当前视图相关的场景信息，包括相机的信息，游戏时间或者其他渲染需要的信息。这也是一个适合添加自定义全局Uniform参数的地方。在这个ShaderParameters中， 4.22加入了StructuredBuffer类型，可以传递数组进StructuredBuffer，名称为PrimitiveSceneData的Buffer包含所有GPU实例化的图元数据。 IMPLEMENT_Macro(SceneView.cpp)上文提到过，实现宏创建元数据并且保存到全局的容器中。另外，这个宏也会帮助着色器编译器为GPU生成着色器代码。例如着色器编译器会生成一个”cbuffer Primitive{}”和”cbuffer View{}”，名称是传进宏里的名称。cbuffer的内容也是从FPrimitiveUniformShaderParameters或FViewUniformShaderParameters反射的。 （提示：当不支持自动实例化时，就会使用cubuffer Primitive，因此每个Drawcall现在的图元会绑定它的UniformBuffer到cbuffer。当自动实例化开启是，就不使用这个cbuffer了，而是使用ViewUniform中的StructuredArray”PrimitiveSceneData” 。） GPU：生成着色器代码之前讨论过，cbuffer结构中的着色器代码在任何.ush文件中都没有预先定义，它们是在编译着色器的时候生成的。下面大致看下原理。1234567891011121314151617181920212223242526272829303132333435363738394041//////////////////////// ShaderCompiler.cpp//////////////////////void GlobalBeginCompileShader(…)&#123; … // 设置编译标识，添加任务到队列，编译器稍后会调用该任务 NewJobs.Add(NewJob);&#125;//////////////////////////// ShaderCompileWorker.cpp//////////////////////////static void ProcessCompilationJob(…)&#123; ... // 调用ShaderFormatD3D.cpp::CompileShader() (D3D) Compiler-&gt;CompileShader(…);&#125;////////////////////////// D3DShaderCompiler.cpp////////////////////////void CompileShader_Windows_SM5(…)&#123; … CompileD3DShader(…);&#125;void CompileD3DShader(…)&#123; … if (Input.RootParameterBindings.Num()) &#123; // 生成全局ShaderParameters的cbuffer代码，将字符串放在PreprocessedShaderSource中 MoveShaderParametersToRootConstantBuffer(Input, PreprocessedShaderSource); &#125; // 处理字符串：修改代码便于从\"cbuffer.memberData\"到\"cbuffer_memberData\"的代码允许cbuffer访问。 RemoveUniformBuffersFromSource(Input.Environment, PreprocessedShaderSource); …&#125;着色器代码是在MoveShaderParametersToRootConstantBuffer()中生成的，然后RemoveUniformBuffersFromSource()会对着色器代码进行调整。[cbuffer_name].[dataMember]会转化成[cbuffer_name]_[dataMember]，例如View.LocalToWorld会变成View_LocalToWorld。 1234567891011121314151617181920212223242526// ShaderCompilerCommon.cpp:void MoveShaderParametersToRootConstantBuffer(…)&#123; … /* Print the string \"cbuffer &#123;…&#125;\" , but looks like this is still an intermediate code, the string will be proccessed later again, but I don't trace too much in this part */ // 输出字符串\"cbuffer&#123;...&#125;\", 但貌似只是过渡，后面字符串还会被处理一次。 FString NewShaderCode = FString::Printf( TEXT(\"cbuffer %s\\r\\n\") TEXT(\"&#123;\\r\\n\") TEXT(\"%s\") TEXT(\"&#125;\\r\\n\\r\\n%s\"), FShaderParametersMetadata::kRootUniformBufferBindingName, *RootCBufferContent, *PreprocessedShaderSource); PreprocessedShaderSource = MoveTemp(NewShaderCode);&#125;// 交叉编译器还不支持结构体初始化，用名称替换所有的uniform缓冲结构体成员的引用。// 例如View.WorldToClip变成View_WorldToClip，移除结构体的依赖。void RemoveUniformBuffersFromSource(…)&#123; … /* 'OpaqueBasePass.Shared.Reflection .SkyLightCubemapBrightness' -&gt; 'OpaqueBasePass_Shared_Reflection_SkyLightCubemapBrightness ' */ …&#125; 生成的着色器代码下方的两个文件在vs中是找不到的，因为它们是在编译时自动生成的。但是，可以修改着色器编译器设置来显示debug信息。在ConsoleVariables.ini中添加r.Shaders.Optimize=0和r.Shaders.KeepDebugInfo=1。然后就可以用RenderDoc抓帧查看资源包括着色器代码。在View.ush和Primitive.ush中，可以看到cbuffer的内容与C++宏声明的着色器参数是一一对应的，而变量的前缀则是结构体的名称。 更新和绑定缓冲更新缓冲和绑定缓冲是不同的。更新需要获取参数的数据然后更新数据到UniformBuffer；绑定缓冲是告诉着色器我们将要使用哪些缓冲。例如，我们有十个UniformBuffer，它们是不同Views, Primitivies等等的缓冲，它们会在任意的drawcall前更新。但是渲染一个模型时，如果着色器只需要十个中的两个，只需要绑定其中的两个缓冲到着色器。 SceneRendering.cpp不同的uniform参数可以有自己的更新管线，所以它们可以在不同的地方更新。这里会展示一下更新ViewUniformBufferParameter的位置。从DeferredShadingRenderer.cpp::Render()可以追踪到InitViews()，最后到SceneRendering.cpp::SetupUniformBufferParameters()，此处设置了FViewUniformBufferParameter的数据。123456789/* SceneRendering.cpp */void FViewInfo::SetupUniformBufferParameters(…)&#123; … SetupCommonViewUniformBufferParameters(…); …&#125;/* SceneView.cpp */void FSceneView::SetupCommonViewUniformBufferParameters()&#123;…&#125; ClobalShader.h这是绑定缓冲的地方，同样地，不同的渲染pass可以在不同的地方绑定缓冲。发送drawcall的时候缓冲绑定几乎已经完成。因为绑定缓冲意味着链接缓冲到着色器，所以必须同时传递shaderRHI和缓冲到函数中。12345inline void SetParameters(…, ShaderRHI, ViewUniformBuffer)&#123; … SetUniformBufferParameter(…, ShaderRHI, …, ViewUniformBuffer);&#125; D3D11StateCachePrivate.hSetUniformBufferParameter()最终会来到InternalSetSetConstantBuffer()函数，这个函数会调用D3D11 API [Type]SetConstantBuffers到一个顶点/外壳/域/几何/像素/计算着色器。绑定工作在此时完成。123456D3D11_STATE_CACHE_INLINE void InternalSetSetConstantBuffer(…)&#123; … case SF_Vertex: Direct3DDeviceIMContext-&gt;VSSetConstantBuffers(…); break; …&#125; 添加Uniform控制参数添加参数因为要向View添加一个全局uniform，所以在SceneView.h添加一个VIEW_UNIFORM_BUFFER_MEMBER。 更新参数值可以借用SkyLightComponent和Proxy来存放自定义的uniform，在SetupUniformBufferParameters()中可以把用户编辑过的值传到ViewUniform。SceneRendering.cpp： 添加一个新的UPROPERTY”MyCustomClobalUniform”到SceneManagement.h 添加相应的组件变量在SkyLightSceneProxy中——“MyCustomGlobalUniform”。在代理的构造函数中，复制SkyLightComponent的值。SceneManagement.h： 在着色器代码中访问参数在.ush或.usf文件或材质编辑器的Custom节点中都可以使用View.TestConstantUniform来调用该数值了，并且可以在天光组件的参数面板中修改该数值进行全局控制。 创建材质节点添加节点类在引擎的\\Source\\Runtime\\Engine\\Classes\\Materials 路径下存放了材质编辑器的所有节点源文件。每个节点都有自己的UMaterialExpression类。所以同样在此路径创建一个头文件MaterialExpressionMyGlobalUniform.h。因为此案例只是一个向量数据，可以拷贝DeltaTime的节点。确保添加完头文件后重新生成sln，这样可以自动生成.generated.h文件，否则会编译失败。 然后在MaterialExpressions.cpp中实现它的构造函数 节点的编译器设置在MaterialCompiler.h中添加MyCustomUniform()方法。 在HLSLMaterialTranslator.h中，才是MaterialCompiler真正起作用的地方。调用AddInlinedCodeChunk(DATA_TYPE, CODE_STRING)来实现。 测试保存代码，重新成成sln工程，编译并打开引擎。","categories":[{"name":"Unreal Engine","slug":"Unreal-Engine","permalink":"https://cuihongzhi1991.github.io/categories/Unreal-Engine/"}],"tags":[{"name":"UE4","slug":"UE4","permalink":"https://cuihongzhi1991.github.io/tags/UE4/"},{"name":"材质","slug":"材质","permalink":"https://cuihongzhi1991.github.io/tags/%E6%9D%90%E8%B4%A8/"},{"name":"渲染管线","slug":"渲染管线","permalink":"https://cuihongzhi1991.github.io/tags/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"}]},{"title":"UE4.24 材质Custom节点链接.usf文件","slug":"usf424","date":"2020-04-16T14:19:15.000Z","updated":"2020-04-25T06:29:11.304Z","comments":true,"path":"2020/04/16/usf424/","link":"","permalink":"https://cuihongzhi1991.github.io/2020/04/16/usf424/","excerpt":"UE4材质编辑器中的Custom节点可以写hlsl代码，方便进行一些复杂计算，比如for循环。可以保证材质面板简洁可读性高。UE4之前的版本直接在Custom节点中用#include包含Shaders文件夹下的ush或usf文件，这样可以用外部的代码编辑器编写shader文件。但是最近的版本有所改动，Custom节点无法识别Shaders路径下的文件。所以需要修改工程模块来包含任意路径。","text":"UE4材质编辑器中的Custom节点可以写hlsl代码，方便进行一些复杂计算，比如for循环。可以保证材质面板简洁可读性高。UE4之前的版本直接在Custom节点中用#include包含Shaders文件夹下的ush或usf文件，这样可以用外部的代码编辑器编写shader文件。但是最近的版本有所改动，Custom节点无法识别Shaders路径下的文件。所以需要修改工程模块来包含任意路径。 准备工作 首先创建C++工程，如果是蓝图工程可以添加新的C++类，会自动转成C++工程。假设项目名称为MotionBlur。 修改MotionBlur.Build.cs: 12345678910111213141516using UnrealBuildTool;public class MotionBlur : ModuleRules&#123; public MotionBlur(ReadOnlyTargetRules Target) : base(Target) &#123; PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs; PublicDependencyModuleNames.AddRange(new string[] &#123; \"Core\", \"CoreUObject\", \"Engine\", \"InputCore\", // 添加依赖模块，旧版是ShaderCore,现在改为RenderCore \"RHI\", \"RenderCore\" &#125;); // 添加依赖项Projects，可以识别工程路径 PrivateDependencyModuleNames.AddRange(new string[] &#123;\"Projects\"&#125;); &#125;&#125; 修改MotionBlur.h: 123456789#pragma once#include \"CoreMinimal.h\"class FMotionBlurModule : public IModuleInterface&#123;public: virtual void StartupModule() override; virtual void ShutdownModule() override;&#125;; 修改MotionBlur.cpp: 12345678910111213141516171819#include \"MotionBlur.h\"#include \"Modules/ModuleManager.h\"#include \"Misc/Paths.h\"#include \"ShaderCore.h\"IMPLEMENT_MODULE(FMotionBlurModule, MotionBlur);void FMotionBlurModule::StartupModule() &#123; // 获取工程路径，并指定usf文件存放的路径为工程的Shaders文件夹 FString ShaderDirectory = FPaths::Combine(FPaths::ProjectDir(), TEXT(\"Shaders\")); // 路径映射Csutom节点直接写#include\"/Project/xxx.usf\"即可 AddShaderSourceDirectoryMapping(\"/Project\", ShaderDirectory);&#125;void FMotionBlurModule::ShutdownModule()&#123; ResetAllShaderSourceDirectoryMappings();&#125; 使用 函数可以放在统一的Custom节点，只有主要执行节点才可以识别输入的参数 .usf文件要放在工程路径下的Shaders文件夹（之前在CPP里自定义的路径）","categories":[{"name":"Unreal Engine","slug":"Unreal-Engine","permalink":"https://cuihongzhi1991.github.io/categories/Unreal-Engine/"}],"tags":[{"name":"UE4","slug":"UE4","permalink":"https://cuihongzhi1991.github.io/tags/UE4/"},{"name":"材质","slug":"材质","permalink":"https://cuihongzhi1991.github.io/tags/%E6%9D%90%E8%B4%A8/"}]}],"categories":[{"name":"图形学","slug":"图形学","permalink":"https://cuihongzhi1991.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"Unreal Engine","slug":"Unreal-Engine","permalink":"https://cuihongzhi1991.github.io/categories/Unreal-Engine/"}],"tags":[{"name":"球面高斯","slug":"球面高斯","permalink":"https://cuihongzhi1991.github.io/tags/%E7%90%83%E9%9D%A2%E9%AB%98%E6%96%AF/"},{"name":"图形学","slug":"图形学","permalink":"https://cuihongzhi1991.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"光照贴图","slug":"光照贴图","permalink":"https://cuihongzhi1991.github.io/tags/%E5%85%89%E7%85%A7%E8%B4%B4%E5%9B%BE/"},{"name":"UE4","slug":"UE4","permalink":"https://cuihongzhi1991.github.io/tags/UE4/"},{"name":"材质","slug":"材质","permalink":"https://cuihongzhi1991.github.io/tags/%E6%9D%90%E8%B4%A8/"},{"name":"渲染管线","slug":"渲染管线","permalink":"https://cuihongzhi1991.github.io/tags/%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"},{"name":"卡通着色","slug":"卡通着色","permalink":"https://cuihongzhi1991.github.io/tags/%E5%8D%A1%E9%80%9A%E7%9D%80%E8%89%B2/"}]}