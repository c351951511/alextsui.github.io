{"meta":{"title":"Alex Technical Art","subtitle":"","description":"","author":"Alex Tsui","url":"https://cuihongzhi1991.github.io","root":"/blog/"},"pages":[{"title":"Real-Time Rendering 4th 笔记——第一章","date":"2020-04-11T12:33:36.000Z","updated":"2020-04-16T14:36:49.284Z","comments":true,"path":"DOING/RTR4Ch01.html","permalink":"https://cuihongzhi1991.github.io/DOING/RTR4Ch01.html","excerpt":"《Real-Time Rendering 4th》出版于2018年，是实时渲染圣经的第四版。此版涵盖的内容延续以往的结构，知识点到为止，展开的并不多。所以根据书中的索引可以对某一方面进行深度学习和研究。","text":"《Real-Time Rendering 4th》出版于2018年，是实时渲染圣经的第四版。此版涵盖的内容延续以往的结构，知识点到为止，展开的并不多。所以根据书中的索引可以对某一方面进行深度学习和研究。 引言实时渲染是计算机图形学交互性最强的领域。操作者做出操作或交互后可以立即得到反馈效果呈现在画面上，并根据产生的图像结果持续交互。这样一个操作与渲染的循环须有足够的计算速度才可以避免观察者看到多张不连贯的图像。图像显示速率以帧数/秒(FPS)或者赫兹(Hz)度量。每秒1帧几乎没有交互性；每秒6帧才有点交互性；游戏的目标是30、60、72或更高的FPS，例如游戏在VR头显设备运行时通常需要90FPS来最小化延迟避免产生眩晕感。实时渲染比交互性更重要，实时渲染一般指创造三维图像。交互性和三维空间关系是实时渲染的充分条件。后来，三维图形的加速硬件（显卡）也成为了实时渲染的第三个元素。不仅是电脑，平板和手机现在也内置了图形处理器。本书会着重提供可以加速和提升画面质量的方法，并且会描述加速算法和图形API的特性及限制。本书不会对每个话题深入讨论，而是展现其核心概念和专业术语，对最鲁棒和最实际的算法进行解释，并给出更多的拓展学习资料。 内容概括 第二章——图形渲染管线将场景的数据化抽象描述转换成我们可以看到的实际画面的步骤就是实时渲染的核心。 第三章——图形处理单元现代GPU使用固定方法与可编程单元的组合来实现渲染管线的各个步骤。 第四章——变换变换是修改物体位置、朝向、比例和形状的基本工具，也是修改相机位置和FOV的基本工具。 第五章——基础着色从讨论材质和灯光的含义开始，并实现写实或风格化的材质效果。另外还会介绍一些效果相关的话题，比如通过反走样、半透和伽马矫正得到质量更佳的图像。 第六章——纹理快速读取和在表面上显示图像的能力是实时渲染的强力工具之一。这个过程被称为纹理映射，有着很广泛的应用方法。 第七章——阴影给场景添加阴影既可以提升真实感也便于理解空间关系。本章会快速展示一下常用的计算阴影的算法。 第八章——光和色彩在呈现基于物理的渲染之前，需要理解如何量化光和色彩。在物理渲染过程结束后，需要转换结果为数值来展示效果，包括屏幕和观察环境的多种属性。 第九章——基于物理的着色本章会透彻讲解对基于物理的着色。会介绍背后的物理现象、各种渲染材质的数学模型、混合材质和反走样的过滤方法。 第十章——局部照明探索更精准的光照算法。当光源具有特殊形状时是如何计算表面的着色。 第十一章——全局照明模拟灯光和场景多次交互的算法大大增加图像的真实性。会讨论直接和间接光遮蔽以及渲染漫反射和镜面反射表面的全局光照的方法，还有一些可信的统一实现方式。 第十二章——图像效果图形硬件擅长快速处理图像。会先介绍图像过滤和重映射技术，然后讨论几个流行的后期处理效果，如：镜头炫光、运动模糊和景深。 第十三章——物体的其他描述形式三角形不总是描述物体最快和最真实的方式。还有一些基于图像、点云、体素和其他采样集合的方式都有各自的优点。 第十四章——体积和半透渲染重现体积感材质的理论和实践，他们是如何与光照进行交互的。从宏观的大范围氛围效果到微观如发丝的光照散射都有模拟。 第十五章——非真实感渲染让场景看起来真实只是渲染的方法之一。还可以探讨其他类型，如卡通着色、水彩风格等，线条和文本的生成技术也会在此讨论。 第十六章——多边形技术几何数据来源广泛，有时为了快速渲染和提高渲染质量会修改数据。本章会介绍描述和压缩多边形数据技术的多个方面。 第十七章——曲线和曲面更复杂的表面描述方式提供了其他的优点，比如可以在质量和渲染速度上做取舍、更加细致的描述以及生成平滑的表面。 第十八章——管线优化当应用程序使用高效的算法运行时，可以使用各种优化技术更快的运行。找到瓶颈并且决定如何解决瓶颈是本章的主题。多重处理也会在此讨论。 第十九章——加速算法不仅能运行，还要更快速。本章涵盖了各种剔除和LOD渲染方法。 第二十章——高效的着色方式在场景中，大量的光源会导致性能的下降。在片段可见性未知的情况下对其完整的渲染是浪费的。此处会探索一些可以解决这种低效着色的办法。 第二十一章——虚拟现实和增强现实该领域有其特殊的挑战和技术来实现真实、快速并且稳定的图像。 第二十二章——相交测试方法相交测试对渲染、玩家交互和碰撞检测都十分重要。本章会介绍很多几何体相交测试的高效算法。 第二十三章——图形硬件本章会介绍颜色深度、帧缓冲和基础的架构类型。给出了一个典型的GPU实例分析。 第二十四章——未来让我们猜猜看。 符号和定义TO DO 数学符号TO DO 几何定义TO DO 着色TO DO 其他学习资源Real-Time Rendering官网"},{"title":"categories","date":"2020-04-11T09:45:58.000Z","updated":"2020-04-11T09:54:15.732Z","comments":false,"path":"categories/index.html","permalink":"https://cuihongzhi1991.github.io/categories/index.html","excerpt":"","text":""},{"title":"UE4制作《地平线》体积云","date":"2020-04-17T15:30:14.000Z","updated":"2020-04-19T14:29:10.940Z","comments":true,"path":"DOING/VC-HZD2016.html","permalink":"https://cuihongzhi1991.github.io/DOING/VC-HZD2016.html","excerpt":"","text":"概览游戏中的实时体积云往往为了降低性能而降低质量。最成功的实现仅限于低空的蓬松半透的层状云。开发者提出一种有体积感的解决方案，可以用各种类型的云填满整个天空，十分真实。不仅描绘了高空的卷云，还有所有低云族的主要类型，包括厚的卷积云。另外，开发者的几中体积光效果的模拟方法还没有在这个体积云方案中呈现。最后，这个解决方案在内存和GPU开销方面表现得足够好，可以在3A的主机游戏中使用。 简介3A主机游戏云渲染的标准方案包括某些素材，比如2D公告板、带穹顶图的天空球或者体积素材库在渲染时进行实例化。像开放世界这样天空需要不断变化并且玩家视距非常远的游戏中，数据储存、多个相机角度、TOD和不同光照条件下的数据读取使得高细节资源的优势黯然失色。另外，云系统演化过程的模拟仅限于作假的方式，比如旋转天空球或者用2D噪波扭曲云的贴图。有许多不依赖资产的程序化云系统的技术。ShaderToy.com上有几个很好的免费案例，比如Quilez的“Clouds”。索尼的Evolution Studios在游戏《驾驶俱乐部》中使用TrueSky的插件呈现氛围感很强的天气效果。然而这种方式也有几个限制： 它们只描述了低高度的层云，不是蓬松汹涌的层积云或积云。 现有的方法没有针对特定的云实现真实的光照效果。 正常情况下，实时体积云性能开销很高，内存占用多，不值得为了质量好而牺牲这么多。对于游戏《地平线：黎明时分》，开发者研发了新的解决方案来解决上述的问题。他们为体积云的建模、光照和渲染提出了新的算法，在内存预算20MB和实时性能2ms的情况下实现真实和逐步演变的效果。 云的建模。。。。。。。。。。。。。。。。"},{"title":"tags","date":"2020-04-11T09:44:03.000Z","updated":"2020-04-11T09:54:17.823Z","comments":false,"path":"tags/index.html","permalink":"https://cuihongzhi1991.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"UE4.22+ 添加自定义卡通着色模型","slug":"ue4addshadingmodel","date":"2020-04-25T06:14:25.000Z","updated":"2020-04-27T13:12:47.548Z","comments":true,"path":"2020/04/25/ue4addshadingmodel/","link":"","permalink":"https://cuihongzhi1991.github.io/2020/04/25/ue4addshadingmodel/","excerpt":"UE4中内置了一些着色模型(Shading Model)，基本满足了绝大部分游戏开发的需求。但一些特殊美术风格的游戏也许需要自定义着色模型，比如当下火热的二次元向游戏。本文记录了4.22+版本添加自定义着色模型的方法。","text":"UE4中内置了一些着色模型(Shading Model)，基本满足了绝大部分游戏开发的需求。但一些特殊美术风格的游戏也许需要自定义着色模型，比如当下火热的二次元向游戏。本文记录了4.22+版本添加自定义着色模型的方法。 创建自定义着色模型添加着色模型类型在EngineTypes.h中为自定义的着色模型添加一个新的UENUM。MaterialShader.cpp 添加一个枚举只是可以在材质编辑器看到而已，必须要定义这个着色模型。首先要设置编译这个着色器的环境。通过SetDefine()实现。SetDefine()函数的作用是为着色器添加一个属性的#define预处理器，编译着色器时就知道按照何种着色模型去编译。下面的代码就会让着色器编译器将MATERIAL_SHADINGMODEL_CEL_SHADING认作1.HLSLMaterialTranslator.h 开启材质引脚将会使用CustomData0和1作为Cel Bands和Outline Thickness的引脚。只需要在Material.cpp中的MP_CustomData0和MP_CustomData1之后添加开启条件。 CustomData可以保持CustomData0或1的引脚名称，也可以自定义名字。在MaterialGraph.cpp中的GetCustomDataPinName()中添加着色模型对应的引脚名称。 另外CustomData0和1的范围是0到1，所以大于1的数值n操作最好用1/n做后续数学计算。可以在AllocGBufferTargets()函数中看到UE4使用的是B8G8R8A8存储GBuffer的，CustomData的数据是储存在R或G通达的，8-bit小数最大值会被限制1.0。 借Refraction的引脚修改case MP_Refraction引脚的激活条件。 但是编译材质图标节点到着色器代码时，UE会检查冗余和不持支的内容，不支持的部分就会丢弃掉，或者被默认值代替。在HLSLMaterialTranslator.h的Translate()中，Refraction引脚只有混合模式为半透的时候才会编译，所以修改一下编译条件。 在MaterialGraph.cpp的RebuildGraph()函数中可以修改Refraction引脚名称的实现方式，用GetRefractionPinName()函数获取最终名称。 现在已经修改好所有的cpp和h文件,可以编译引擎工程。 修改着色器：BasePass和GBuffer建立着色模型ID和颜色在ShadingCommon.ush中定义新的SHADINGMODELID，并设置ID和颜色 为了让GBuffer输出CustomData，需要在BasePassCommon.ush中扩展输出条件 输出GBuffer数据的准备工作ShadingModelsMaterial.ush中的SetGBufferForShadingModel()函数会设置GBuffer的数据，添加Cel着色模型的情况。 但是Refraction引脚的数据需要用GetMaterialRefraction(FPixelMaterialInputs PixelMaterialInputs)，可以在BasePassPixelShader.ush中使用PixelMaterialInpus输入参数得到Refraction引脚的数据。 修改着色器：DeferredPass和Lighting光照调整DeferredLightPixelMain()函数在DeferredLightPixelShaders.usf中。颜色是通过GetDynamicLighting()函数实现的，该函数位于DeferredLightingCommon.ush中。首先获取阴影项，然后调用函数IntegrateBxDF()函数得到光照项。在该函数中，不同的着色模型会执行不同的BxDF()，所以可以在ShadingModels.ush的IntegratedBxDF()函数中添加CelShadingBxDF()。可以以DefaultLitBxDF()为基础修改和扩展。 阴影调整阴影还是默认的柔和，在GetDynamicLighting()中的IntegrateBxDF()前调用了GetShadowTerms()。在计算光照颜色的时候将LightColor与LightMask和Shadow.SurfaceShadow进行了相乘。所以只需要对LightMask和Shadow.SurfaceShadow进行一步处理，得到分层的锐利阴影即可。DeferredLightingCommon.ush 反射调整在ReflectionEnvironmentPixelShader.ush文件中加入判断条件，如果是卡通着色模型，就转为LAB格式调整亮度再转回RGB。 描边因为是延迟渲染，所以可以在延迟光照的步骤可以拿到深度和法线做描边。 修改代码在DeferredLightPixelShaders.usf的DeferredLightPixelMain()中添加函数CalcSceneDepth()。SceneTexturesStruct包含了GBufferA/B/C/DTexture，场景深度就在其中。法线存在GBufferA。","categories":[{"name":"Unreal Engine","slug":"Unreal-Engine","permalink":"https://cuihongzhi1991.github.io/categories/Unreal-Engine/"}],"tags":[{"name":"UE4","slug":"UE4","permalink":"https://cuihongzhi1991.github.io/tags/UE4/"},{"name":"材质","slug":"材质","permalink":"https://cuihongzhi1991.github.io/tags/%E6%9D%90%E8%B4%A8/"},{"name":"卡通着色","slug":"卡通着色","permalink":"https://cuihongzhi1991.github.io/tags/%E5%8D%A1%E9%80%9A%E7%9D%80%E8%89%B2/"}]},{"title":"UE4.22+ 添加Uniform","slug":"ue4uniform","date":"2020-04-23T05:10:39.000Z","updated":"2020-04-25T06:17:48.487Z","comments":true,"path":"2020/04/23/ue4uniform/","link":"","permalink":"https://cuihongzhi1991.github.io/2020/04/23/ue4uniform/","excerpt":"Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式，Uniform是全局的(Global)。全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。第二，无论你把Uniform值设置成什么，Uniform会一直保存它们的数据，直到它们被重置或更新。UE4的材质编辑器可以调用的红色节点中很多就是Uniform，如ObjectBounds，ActorPosition等等。本文记录了如何在UE4.22或更高版本添加自定义的Uniform，并且生成材质节点在任意材质中调用，该Uniform值也将显示在场景的Skylight组件上供用户修改。","text":"Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式，Uniform是全局的(Global)。全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。第二，无论你把Uniform值设置成什么，Uniform会一直保存它们的数据，直到它们被重置或更新。UE4的材质编辑器可以调用的红色节点中很多就是Uniform，如ObjectBounds，ActorPosition等等。本文记录了如何在UE4.22或更高版本添加自定义的Uniform，并且生成材质节点在任意材质中调用，该Uniform值也将显示在场景的Skylight组件上供用户修改。 创建CPU中的数据结构体FShaderParametersMetadata这是一个4.22的新类，4.21有一个类似的结构体FUniformBufferStruct。4.22中可以在ShaderParameterMetadata.h中找到这个类。FShaderParametersMetadata是一个储存了多个着色器参数的集合或容器。该容器可以储存不同数据类型的参数。每个参数都是一个成员，可以是矩阵、向量、数组或者纹理。（提示：FShaderParameter.h中还定义了另外一个着色器参数系统。有FShaderParameter, FShaderResourceParameter, FShaderUniformBufferParameter等等。依然可以在单独的着色器中使用，如在LightRendering.cpp中一样。）如果要定义一组着色器参数，可以用宏来声明这些元数据，这是将它们放进UniformBuffer的快捷办法。 ShaderParameterMacros.h这个头文件中包含了一些声明参数结构体的宏。比如BEGIN_GLOBAL_SHADER_PARAMETER_STRUCT()和END_GLOBAL_SHADER_PARAMETER_STRUCT()。这两个宏创建了一个类作为ParameterMetadata的壳，如： 123456789// Begin Macro:class STRUCT_NAME &#123;static Metadata;CreateUniformBuffer() (when declare as GLOBAL)...Parameter Macro: Insert all members (Parameter)...// End:some ending stuff + &#125; 对于全局的参数结构体，cpp中需要添加另外一个宏： IMPLEMENT_GLOBAL_SHADER_PARAMETER_STRUCT(FMyParameterStruct, “MyShaderBindingName”);这个宏将静态的元数据放入一个全局的容器，扩展后的宏类似下方： 12FShaderParametersMetadata StructTypeName::Metadata(...);=&gt; FShaderParametersMetadata(..) &#123; Add-Self-To-Global-Container &#125; 现在有了元数据的壳，可以开始使用SHADER_PARAMETER(Type, Name) 添加一些参数到壳中，用类型和名称创建一个成员，然后添加该成员到元数据的成员数组中。（提示：有两个版本的声明：GLOBAL和LOCAL，区别是GLOBAL会在类中创建一个UniformBuffer并且所有成员会放进这个缓冲中，另外GLOBAL会将元数据保存在全局的map和list中。而LOCAL方式不会创建内在的UniformBuffer，所以不用调用IMPLEMENT_宏。)##案例：Primitive Uniform, View Uniform可以参考一下PrimitiveUniform和ViewUniform，两个最重要的UniformShaderParameters。 PrimitiveUniformShaderParameters.h该头文件中声明了一个FPrimitiveUniformShaderParameters的结构体。之所以比较重要是因为在检索着色器代码的时候经常会看到”Primitive”或”GetPrimitiveData()“这样的变量，都是来自这个uniform结构体的。它保存了一个图元（或图元组件）的信息，包括LocalToWorld, WorldToLocal等等。 FViewUniformShaderParameters(SceneView.h)可以认为这是当前视图相关的场景信息，包括相机的信息，游戏时间或者其他渲染需要的信息。这也是一个适合添加自定义全局Uniform参数的地方。在这个ShaderParameters中， 4.22加入了StructuredBuffer类型，可以传递数组进StructuredBuffer，名称为PrimitiveSceneData的Buffer包含所有GPU实例化的图元数据。 IMPLEMENT_Macro(SceneView.cpp)上文提到过，实现宏创建元数据并且保存到全局的容器中。另外，这个宏也会帮助着色器编译器为GPU生成着色器代码。例如着色器编译器会生成一个”cbuffer Primitive{}”和”cbuffer View{}”，名称是传进宏里的名称。cbuffer的内容也是从FPrimitiveUniformShaderParameters或FViewUniformShaderParameters反射的。 （提示：当不支持自动实例化时，就会使用cubuffer Primitive，因此每个Drawcall现在的图元会绑定它的UniformBuffer到cbuffer。当自动实例化开启是，就不使用这个cbuffer了，而是使用ViewUniform中的StructuredArray”PrimitiveSceneData” 。） GPU：生成着色器代码之前讨论过，cbuffer结构中的着色器代码在任何.ush文件中都没有预先定义，它们是在编译着色器的时候生成的。下面大致看下原理。 1234567891011121314151617181920212223242526272829303132333435363738394041//////////////////////// ShaderCompiler.cpp//////////////////////void GlobalBeginCompileShader(…)&#123; … // 设置编译标识，添加任务到队列，编译器稍后会调用该任务 NewJobs.Add(NewJob);&#125;//////////////////////////// ShaderCompileWorker.cpp//////////////////////////static void ProcessCompilationJob(…)&#123; ... // 调用ShaderFormatD3D.cpp::CompileShader() (D3D) Compiler-&gt;CompileShader(…);&#125;////////////////////////// D3DShaderCompiler.cpp////////////////////////void CompileShader_Windows_SM5(…)&#123; … CompileD3DShader(…);&#125;void CompileD3DShader(…)&#123; … if (Input.RootParameterBindings.Num()) &#123; // 生成全局ShaderParameters的cbuffer代码，将字符串放在PreprocessedShaderSource中 MoveShaderParametersToRootConstantBuffer(Input, PreprocessedShaderSource); &#125; // 处理字符串：修改代码便于从\"cbuffer.memberData\"到\"cbuffer_memberData\"的代码允许cbuffer访问。 RemoveUniformBuffersFromSource(Input.Environment, PreprocessedShaderSource); …&#125; 着色器代码是在MoveShaderParametersToRootConstantBuffer()中生成的，然后RemoveUniformBuffersFromSource()会对着色器代码进行调整。[cbuffer_name].[dataMember]会转化成[cbuffer_name]_[dataMember]，例如View.LocalToWorld会变成View_LocalToWorld。 1234567891011121314151617181920212223242526// ShaderCompilerCommon.cpp:void MoveShaderParametersToRootConstantBuffer(…)&#123; … /* Print the string \"cbuffer &#123;…&#125;\" , but looks like this is still an intermediate code, the string will be proccessed later again, but I don't trace too much in this part */ // 输出字符串\"cbuffer&#123;...&#125;\", 但貌似只是过渡，后面字符串还会被处理一次。 FString NewShaderCode = FString::Printf( TEXT(\"cbuffer %s\\r\\n\") TEXT(\"&#123;\\r\\n\") TEXT(\"%s\") TEXT(\"&#125;\\r\\n\\r\\n%s\"), FShaderParametersMetadata::kRootUniformBufferBindingName, *RootCBufferContent, *PreprocessedShaderSource); PreprocessedShaderSource = MoveTemp(NewShaderCode);&#125;// 交叉编译器还不支持结构体初始化，用名称替换所有的uniform缓冲结构体成员的引用。// 例如View.WorldToClip变成View_WorldToClip，移除结构体的依赖。void RemoveUniformBuffersFromSource(…)&#123; … /* 'OpaqueBasePass.Shared.Reflection .SkyLightCubemapBrightness' -&gt; 'OpaqueBasePass_Shared_Reflection_SkyLightCubemapBrightness ' */ …&#125; 生成的着色器代码下方的两个文件在vs中是找不到的，因为它们是在编译时自动生成的。但是，可以修改着色器编译器设置来显示debug信息。在ConsoleVariables.ini中添加r.Shaders.Optimize=0和r.Shaders.KeepDebugInfo=1。然后就可以用RenderDoc抓帧查看资源包括着色器代码。在View.ush和Primitive.ush中，可以看到cbuffer的内容与C++宏声明的着色器参数是一一对应的，而变量的前缀则是结构体的名称。 更新和绑定缓冲更新缓冲和绑定缓冲是不同的。更新需要获取参数的数据然后更新数据到UniformBuffer；绑定缓冲是告诉着色器我们将要使用哪些缓冲。例如，我们有十个UniformBuffer，它们是不同Views, Primitivies等等的缓冲，它们会在任意的drawcall前更新。但是渲染一个模型时，如果着色器只需要十个中的两个，只需要绑定其中的两个缓冲到着色器。 SceneRendering.cpp不同的uniform参数可以有自己的更新管线，所以它们可以在不同的地方更新。这里会展示一下更新ViewUniformBufferParameter的位置。从DeferredShadingRenderer.cpp::Render()可以追踪到InitViews()，最后到SceneRendering.cpp::SetupUniformBufferParameters()，此处设置了FViewUniformBufferParameter的数据。 123456789/* SceneRendering.cpp */void FViewInfo::SetupUniformBufferParameters(…)&#123; … SetupCommonViewUniformBufferParameters(…); …&#125;/* SceneView.cpp */void FSceneView::SetupCommonViewUniformBufferParameters()&#123;…&#125; ClobalShader.h这是绑定缓冲的地方，同样地，不同的渲染pass可以在不同的地方绑定缓冲。发送drawcall的时候缓冲绑定几乎已经完成。因为绑定缓冲意味着链接缓冲到着色器，所以必须同时传递shaderRHI和缓冲到函数中。 12345inline void SetParameters(…, ShaderRHI, ViewUniformBuffer)&#123; … SetUniformBufferParameter(…, ShaderRHI, …, ViewUniformBuffer);&#125; D3D11StateCachePrivate.hSetUniformBufferParameter()最终会来到InternalSetSetConstantBuffer()函数，这个函数会调用D3D11 API [Type]SetConstantBuffers到一个顶点/外壳/域/几何/像素/计算着色器。绑定工作在此时完成。 123456D3D11_STATE_CACHE_INLINE void InternalSetSetConstantBuffer(…)&#123; … case SF_Vertex: Direct3DDeviceIMContext-&gt;VSSetConstantBuffers(…); break; …&#125; 添加Uniform控制参数添加参数因为要向View添加一个全局uniform，所以在SceneView.h添加一个VIEW_UNIFORM_BUFFER_MEMBER。 更新参数值可以借用SkyLightComponent和Proxy来存放自定义的uniform，在SetupUniformBufferParameters()中可以把用户编辑过的值传到ViewUniform。SceneRendering.cpp： 添加一个新的UPROPERTY”MyCustomClobalUniform”到SceneManagement.h 添加相应的组件变量在SkyLightSceneProxy中——“MyCustomGlobalUniform”。在代理的构造函数中，复制SkyLightComponent的值。SceneManagement.h： 在着色器代码中访问参数在.ush或.usf文件或材质编辑器的Custom节点中都可以使用View.TestConstantUniform来调用该数值了，并且可以在天光组件的参数面板中修改该数值进行全局控制。 创建材质节点添加节点类在引擎的\\Source\\Runtime\\Engine\\Classes\\Materials 路径下存放了材质编辑器的所有节点源文件。每个节点都有自己的UMaterialExpression类。所以同样在此路径创建一个头文件MaterialExpressionMyGlobalUniform.h。因为此案例只是一个向量数据，可以拷贝DeltaTime的节点。确保添加完头文件后重新生成sln，这样可以自动生成.generated.h文件，否则会编译失败。 然后在MaterialExpressions.cpp中实现它的构造函数 节点的编译器设置在MaterialCompiler.h中添加MyCustomUniform()方法。 在HLSLMaterialTranslator.h中，才是MaterialCompiler真正起作用的地方。调用AddInlinedCodeChunk(DATA_TYPE, CODE_STRING)来实现。 测试保存代码，重新成成sln工程，编译并打开引擎。","categories":[{"name":"Unreal Engine","slug":"Unreal-Engine","permalink":"https://cuihongzhi1991.github.io/categories/Unreal-Engine/"}],"tags":[{"name":"UE4","slug":"UE4","permalink":"https://cuihongzhi1991.github.io/tags/UE4/"},{"name":"材质","slug":"材质","permalink":"https://cuihongzhi1991.github.io/tags/%E6%9D%90%E8%B4%A8/"}]},{"title":"UE4.24 材质Custom节点链接.usf文件","slug":"usf424","date":"2020-04-16T14:19:15.000Z","updated":"2020-04-25T06:29:11.304Z","comments":true,"path":"2020/04/16/usf424/","link":"","permalink":"https://cuihongzhi1991.github.io/2020/04/16/usf424/","excerpt":"UE4材质编辑器中的Custom节点可以写hlsl代码，方便进行一些复杂计算，比如for循环。可以保证材质面板简洁可读性高。UE4之前的版本直接在Custom节点中用#include包含Shaders文件夹下的ush或usf文件，这样可以用外部的代码编辑器编写shader文件。但是最近的版本有所改动，Custom节点无法识别Shaders路径下的文件。所以需要修改工程模块来包含任意路径。","text":"UE4材质编辑器中的Custom节点可以写hlsl代码，方便进行一些复杂计算，比如for循环。可以保证材质面板简洁可读性高。UE4之前的版本直接在Custom节点中用#include包含Shaders文件夹下的ush或usf文件，这样可以用外部的代码编辑器编写shader文件。但是最近的版本有所改动，Custom节点无法识别Shaders路径下的文件。所以需要修改工程模块来包含任意路径。 准备工作 首先创建C++工程，如果是蓝图工程可以添加新的C++类，会自动转成C++工程。假设项目名称为MotionBlur。 修改MotionBlur.Build.cs: 12345678910111213141516using UnrealBuildTool;public class MotionBlur : ModuleRules&#123; public MotionBlur(ReadOnlyTargetRules Target) : base(Target) &#123; PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs; PublicDependencyModuleNames.AddRange(new string[] &#123; \"Core\", \"CoreUObject\", \"Engine\", \"InputCore\", // 添加依赖模块，旧版是ShaderCore,现在改为RenderCore \"RHI\", \"RenderCore\" &#125;); // 添加依赖项Projects，可以识别工程路径 PrivateDependencyModuleNames.AddRange(new string[] &#123;\"Projects\"&#125;); &#125;&#125; 修改MotionBlur.h: 123456789#pragma once#include \"CoreMinimal.h\"class FMotionBlurModule : public IModuleInterface&#123;public: virtual void StartupModule() override; virtual void ShutdownModule() override;&#125;; 修改MotionBlur.cpp: 12345678910111213141516171819#include \"MotionBlur.h\"#include \"Modules/ModuleManager.h\"#include \"Misc/Paths.h\"#include \"ShaderCore.h\"IMPLEMENT_MODULE(FMotionBlurModule, MotionBlur);void FMotionBlurModule::StartupModule() &#123; // 获取工程路径，并指定usf文件存放的路径为工程的Shaders文件夹 FString ShaderDirectory = FPaths::Combine(FPaths::ProjectDir(), TEXT(\"Shaders\")); // 路径映射Csutom节点直接写#include\"/Project/xxx.usf\"即可 AddShaderSourceDirectoryMapping(\"/Project\", ShaderDirectory);&#125;void FMotionBlurModule::ShutdownModule()&#123; ResetAllShaderSourceDirectoryMappings();&#125; 使用 函数可以放在统一的Custom节点，只有主要执行节点才可以识别输入的参数 .usf文件要放在工程路径下的Shaders文件夹（之前在CPP里自定义的路径）","categories":[{"name":"Unreal Engine","slug":"Unreal-Engine","permalink":"https://cuihongzhi1991.github.io/categories/Unreal-Engine/"}],"tags":[{"name":"UE4","slug":"UE4","permalink":"https://cuihongzhi1991.github.io/tags/UE4/"},{"name":"材质","slug":"材质","permalink":"https://cuihongzhi1991.github.io/tags/%E6%9D%90%E8%B4%A8/"}]}],"categories":[{"name":"Unreal Engine","slug":"Unreal-Engine","permalink":"https://cuihongzhi1991.github.io/categories/Unreal-Engine/"}],"tags":[{"name":"UE4","slug":"UE4","permalink":"https://cuihongzhi1991.github.io/tags/UE4/"},{"name":"材质","slug":"材质","permalink":"https://cuihongzhi1991.github.io/tags/%E6%9D%90%E8%B4%A8/"},{"name":"卡通着色","slug":"卡通着色","permalink":"https://cuihongzhi1991.github.io/tags/%E5%8D%A1%E9%80%9A%E7%9D%80%E8%89%B2/"}]}